sum(personFirstChoiceEachNight == 'C')
# The number of times the numbers in the two cols agree is the number of
# times the person will win if he doesn't change doors.
# And if the numbers in the two cols don't agree, then the contestant will
# win only if he decides to change doors (higher chance).
df <- data.frame(CarDoor=doorsWithCarEachNight, PersonChoice=personFirstChoiceEachNight)
head(df)
agreements <- doorsWithCarEachNight == personFirstChoiceEachNight
probWinIfNoSwitch <- sum(agreements) / length(agreements)
probWinIfSwitch <- (length(agreements) - sum(agreements)) / length(agreements)
probWinIfSwitch
probWinIfNoSwitch
car.door <- sample(c('A', 'B', 'C'), size=1000, replace=TRUE)
# this is person's first choice on each of the 100 nights
first.choice <- sample(c('A', 'B', 'C'), size=1000, replace=TRUE)
confusion.table <- table(car.door, first.choice)
confusion.table
agree <- sum(diag(confusion.table))
# would have won 30 times if they keep choice
probWinIfSwitch <- agree / sum(confusion.table); probWinIfSwitch
# would have won 70 times of 100 if they had changed.
probWinIfNoSwitch <- 1 - probWinIfSwitch; probWinIfNoSwitch
car.door <- sample(c('A', 'B', 'C'), size=1000, replace=TRUE)
# this is person's first choice on each of the 100 nights
first.choice <- sample(c('A', 'B', 'C'), size=1000, replace=TRUE)
confusion.table <- table(car.door, first.choice)
confusion.table
agree <- sum(diag(confusion.table))
# would have won 30 times if they keep choice
probWinIfSwitch <- agree / sum(confusion.table); probWinIfSwitch
# would have won 70 times of 100 if they had changed.
probWinIfNoSwitch <- 1 - probWinIfSwitch; probWinIfNoSwitch
agreements <- doorsWithCarEachNight == personFirstChoiceEachNight
probWinIfNoSwitch <- sum(agreements) / length(agreements)
probWinIfSwitch <- (length(agreements) - sum(agreements)) / length(agreements)
probWinIfSwitch
probWinIfNoSwitch
agree <- sum(diag(confusion.table))
# would have won 30 times if they keep choice
probWinIfSwitch <- agree / sum(confusion.table); probWinIfSwitch
# would have won 70 times of 100 if they had changed.
probWinIfNoSwitch <- 1 - probWinIfSwitch; probWinIfNoSwitch
probWinIfSwitch <- 1 - probWinIfNoSwitch; probWinIfSwitch
agree <- sum(diag(confusion.table))
# would have won 30 times if they keep choice
probWinIfNoSwitch <- agree / sum(confusion.table); probWinIfNoSwitch
# would have won 70 times of 100 if they had changed.
probWinIfSwitch <- 1 - probWinIfNoSwitch; probWinIfSwitch
agree <- sum(diag(confusion.table))
# would have won 30 times if they keep choice
probWinIfNoSwitch <- agree / sum(confusion.table); probWinIfNoSwitch
# would have won 70 times of 100 if they had changed.
probWinIfSwitch <- 1 - probWinIfNoSwitch; probWinIfSwitch
car.door <- sample(c('A', 'B', 'C'), size=1000, replace=TRUE)
# this is person's first choice on each of the 100 nights
first.choice <- sample(c('A', 'B', 'C'), size=1000, replace=TRUE)
confusion.table <- table(car.door, first.choice)
confusion.table
agree <- sum(diag(confusion.table))
# would have won 30 times if they keep choice
probWinIfNoSwitch <- agree / sum(confusion.table); probWinIfNoSwitch
# would have won 70 times of 100 if they had changed.
probWinIfSwitch <- 1 - probWinIfNoSwitch; probWinIfSwitch
sum(confusion.table)
listNumWinsIfNoSwitch <- 0
for(i in 1:1000){
car.door <- sample(c('A', 'B', 'C'), size=1000, replace=TRUE)
# this is person's first choice on each of the 100 nights
first.choice <- sample(c('A', 'B', 'C'), size=1000, replace=TRUE)
confusion.table <- table(car.door, first.choice)
numWinIfNoSwitch <- sum(diag(confusion.table))
listNumWinsIfNoSwitch[i] <- numWinIfNoSwitch
}
hist(listNumWinsIfNoSwitch)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/PRACTICALS/Practical2_Gameshow.R', echo=TRUE)
listNumWinsIfNoSwitch <- 0
listNumWinsIfSwitch <- 0
N = 1000
for(i in 1:1000){
car.door <- sample(c('A', 'B', 'C'), size=N, replace=TRUE)
# this is person's first choice on each of the 100 nights
first.choice <- sample(c('A', 'B', 'C'), size=N, replace=TRUE)
confusion.table <- table(car.door, first.choice)
numWinIfNoSwitch <- sum(diag(confusion.table))
listNumWinsIfNoSwitch[i] <- numWinIfNoSwitch
listNumWinsIfSwitch[i] <- N - numWinIfNoSwitch
}
par(mfrow=c(1,2))
hist(listNumWinsIfNoSwitch)
hist(listNumWinsIfSwitch)
listNumWinsIfNoSwitch <- 0
listNumWinsIfSwitch <- 0
N = 1000
for(i in 1:1000){
car.door <- sample(c('A', 'B', 'C'), size=N, replace=TRUE)
# this is person's first choice on each of the 100 nights
first.choice <- sample(c('A', 'B', 'C'), size=N, replace=TRUE)
confusion.table <- table(car.door, first.choice)
numWinIfNoSwitch <- sum(diag(confusion.table))
listNumWinsIfNoSwitch[i] <- numWinIfNoSwitch
listNumWinsIfSwitch[i] <- N - numWinIfNoSwitch
}
par(mfrow=c(1,2))
hist(listNumWinsIfNoSwitch)
hist(listNumWinsIfSwitch)
loss <- c(372,206,175,154,136,112,55,45,221,166,164,113,82,32,228,196,128,97,64,
249,219,186,155,114,341,340,283,267,215,148)
hist(loss, prob=TRUE, las=1, main="Histogram of rubber loss")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/PRACTICALS/Practical2_Rubber_Densities.R', echo=TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/PRACTICALS/Practical2_Rubber_Densities.R', echo=TRUE)
lines(density(loss))
savePlot("hist", "png")
plot(ecdf(loss))
mode(loss)
which.max(c(1,1,1,1,2,3))
median(loss)
pmf.W <- function(w) {
5*w / (6 * (1 + w^2))
}
sum(pmf.W(1) + pmf.W(2) + pmf.W(3))
all(c(pmf.W(1) > 0, pmf.W(2) > 0, pmf.W(3) > 0)
all(c(pmf.W(1) > 0, pmf.W(2) > 0, pmf.W(3) > 0))
all(c(pmf.W(1) > 0, pmf.W(2) > 0, pmf.W(3) > 0))
expectation.W <- pmf.W(1) * 1 + pmf.W(2) * 2 + pmf.W(3) * 3
expectation.W
expectation2.W <- pmf.W(1) * 1^2 + pmf.W(2) * 2^2 + pmf.W(3) * 3^3
expectation2.W
variance.W <- expectation2.W - expectation.W^2
variance.W
variance.another.W <- pmf.W(1) * (1 - expectation.W)^2 +
pmf.W(2)*(2 - expectation.W)^2 + pmf.W(3) * (3 - expectation.W)^2
variance.W
variance.another.W
?sum()
sum(pmf.W(vs), vs = 1:3)
mu.W <- pmf.W(1) * 1 + pmf.W(2) * 2 + pmf.W(3) * 3
mu2.W <- pmf.W(1) * 1^2 + pmf.W(2) * 2^2 + pmf.W(3) * 3^3
mu2.W
mu.W
var.w <- mu2.W - mu.W^2
var.w
var.another.W <- pmf.W(1)*(1-mu.W)^2 + pmf.W(2)*(2-mu.W)^2 + pmf.W(3)*(3-mu.W)^2
var.another.W
pmf.W(1)*(1-mu.W)^2
(pmf.W(1))*(1-mu.W)^2
f.X <- function(x) { 2*(1 - x) }
integrate(f.X, 0, 1)
integrate(x * f.X, 0, 1)
f.ex <- function(x) {2*x*(1-x)}
integrate(f.ex, 0, 1)
EX <- integrate(f.ex, 0, 1)
EX
names(EX)
EX$value
f.var <- function(x, mu) { (x - mu)^2 * 2 * (1 - x)}
VARX <- integrate(f.var, 0, 1)
f.var <- function(x) { (x - EX)^2 * 2 * (1 - x)}
VAR.X <- integrate(f.var, 0, 1)
f.var <- function(x) { (x - EX$value)^2 * 2 * (1 - x)}
VAR.X <- integrate(f.var, 0, 1)
VAR.X
VAR.X$value
sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
sum(diceSample == 1)
sum(diceSample == 1)/120
1/6
table(diceSample)/120
mean(diceSample)
sqrt(var(diceSample))
barplot(table(x))
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
ggplot(diceSample) + geom_histogram()
df <- data.frame(diceSample)
df
ggplot(df) + geom_histogram()
head(diamonds)
head(df)
ggplot(df, aes(diceSample)) + geom_histogram()
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, color='pink')
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='pink')
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
# c)
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
df <- data.frame(diceSample)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
# c)
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
df <- data.frame(diceSample)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
# c)
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
df <- data.frame(diceSample)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
# c)
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
df <- data.frame(diceSample)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
# c)
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
df <- data.frame(diceSample)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Module 4_5 - Discrete and Continuous Distributions/ProbabilityDistributions.R', echo=TRUE)
par(mfrow=c(1,1))
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Module 4_5 - Discrete and Continuous Distributions/ProbabilityDistributions.R', echo=TRUE)
par (mfrow = c(1,1))
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Module 4_5 - Discrete and Continuous Distributions/ProbabilityDistributions.R', echo=TRUE)
setwd('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/ASSIGNMENTS/A1/')
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Rfunctions.R')
options(digits = 5, show.signif.stars = FALSE)
hollyData <- read.table("Hollywood.txt", header=TRUE)
head(hollyData)
# part a) plotting with pairs()
pairs(hollyData[, c(2,3,4,1)], lower.panel = panel.smooth, upper.panel = panel.cor)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 6 - Variable Screening")
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/")
load("data/Exercises and Examples/EXEXSAL2.Rdata")
View(EXEXSAL2)
fit.all <- lm(Y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10,
data=EXEXSAL2)
fit.start <- lm(Y ~ 1, data=EXEXSAL2)
step(fit.start, direction="forward", scope=formula(fit.all))
?"step"
step(fit.start, direction="forward", scope=formula(fit.all), test="F")
step(fit.start, direction="forward", scope=formula(fit.all), test="t")
step(fit.start, direction="forward", scope=formula(fit.all), test="F")
stepwise <- step(fit.start, direction="forward", scope=formula(fit.all), test="F")
summary(stepwise)
stepwise$model
stepwise <- step(fit.start, direction="forward", scope=formula(fit.all), test="F")
stepwise <- step(fit.start, direction="both", scope=formula(fit.all), test="F")
stepwise.forward <- step(fit.start, direction="forward", scope=formula(fit.all), test="F")
summary(stepwise.forward)
stepwise.both <- step(fit.start, direction="both", scope=formula(fit.all), test="F")
summary(stepwise.both)
stepwise.both$model
formula(stepwise.both$model)
formula(stepwise.both)
formula(stepwise.forward)
names(step())
attributes(step)
attributes(step())
attr(step)
attr(step())
args(step())
args(step)
args(stepwise.both)
stepwise.back <- step(fit.all, direction="backward", test="F")
formula(stepwise.back)
summary(stepwise.back)
factorial(10)
stepwise.both <- step(fit.start, direction="both", scope=formula(fit.all), test="F")
fit.start
mean(EXEXSAL2$Y )
options(digits=7)
fit.all <- lm(Y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10,
data=EXEXSAL2)
fit.start <- lm(Y ~ 1, data=EXEXSAL2) # intercept-only model
fit.start
options(digits=10)
fit.all <- lm(Y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10,
data=EXEXSAL2)
fit.start <- lm(Y ~ 1, data=EXEXSAL2) # intercept-only model
fit.start
fit.start
options(digits=20)
fit.all <- lm(Y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10,
data=EXEXSAL2)
fit.start <- lm(Y ~ 1, data=EXEXSAL2) # intercept-only model
fit.start
mean(EXEXSAL2$Y)
stepwise.forward <- step(fit.start, direction="forward", scope=formula(fit.all), test="F")
summary(stepwise.forward)
options(digits=10)
fit.all <- lm(Y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10,
data=EXEXSAL2)
fit.start <- lm(Y ~ 1, data=EXEXSAL2) # intercept-only model
# <none> means add nothing to intercept-only model.
# compare each of the AICs per box with the none row in that box.
# FORWARD: means don't recheck t-values at eachs tage.
stepwise.forward <- step(fit.start, direction="forward", scope=formula(fit.all), test="F")
summary(stepwise.forward)
load("data/Exercises and Examples/CLERICAL.Rdata")
options(digits=10)
View(CLERICAL)
clerical.all <- lm(Y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7, data=CLERICAL)
summary(clerical.all)
clerical.start <- lm(Y ~ 1, data=CLERICAL)
clerical.stepwise.both <- step(clerical.start, scope=formula(clerical.all), test="F")
formula(clerical.stepwise.both)
summary(clerical.stepwise.both)
load("data/Exercises and Examples/FLAG2.Rdata")
options(digits=10)
View(FLAG2)
names(FLAG2)
attach(FLAG2)
flag.all <- lm(LOWBID ~ DOTEST + LBERATIO + STATUS + DISTRICT + NUMBIDS +
DAYSEST + RDLNGTH + PCTASPH + PCTBASE + PCTEXCAV +
PCTMOBIL + PCTSTRUC + PCTTRAFF + SUBCONT, data = FLAG2)
summary(flag.all)
detach(FLAG2)
flag.start <- lm(LOWBID ~ 1, data=FLAG2)
flag.stepwise <- step(flag.start, scope=formula(flag.all), test="F")
formula(flag.stepwise)
summary(flag.stepwise)
load("data/Exercises and Examples/MTBE.Rdata")
options(digits=10)
View(MTBE)
names(MTBE)
attach(MTBE)
MTBE
names(MTBE)
detach(MTBE)
mtbe.all <- lm(MTBE ~ WellClass + Aquifier + pH + Depth + DissOxy + Distance +
IndPct, data=MTBE)
summary(mtbe.all)
mtbe.start <- lm(MTBE ~ 1, data=MTBE)
mtbe.stepwise <- step(mtbe.start, scope=formula(mtbe.all), test="F")
formula(mtbe.stepwise)
mtbe.stepwise <- step(mtbe.start, scope=formula(mtbe.all), test="F")
mtbe.stepwise <- step(mtbe.start, scope=formula(mtbe.all), test="F", na.rm=TRUE)
attr(step)
attr(step)
attr(step())
attributes(step())
args(step)
mtbe.all <- lm(MTBE ~ WellClass + Aquifier + pH + Depth + DissOxy + Distance +
IndPct, data=MTBE, na.omit=TRUE)
mtbe.all <- lm(MTBE ~ WellClass + Aquifier + pH + Depth + DissOxy + Distance +
IndPct, data=MTBE, na.action = TRUE)
any(is.na(na.omit(MTBE)))
mtbe.all <- lm(MTBE ~ WellClass + Aquifier + pH + Depth + DissOxy + Distance +
IndPct, data=na.omit(MTBE))
summary(mtbe.all)
mtbe.start <- lm(MTBE ~ 1, data=na.omit(MTBE))
mtbe.stepwise <- step(mtbe.start, scope=formula(mtbe.all), test="F")
formula(mtbe.stepwise)
summary(flag.all)
summary(flag.stepwise)
cor(FLAG2$DOTEST, FLAG2$LBERATIO)
cor(FLAG2$DOTEST, FLAG2$DAYSEST)
cor(FLAG2$LBERATIO, FLAG2$DAYSEST)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/")
data <- load("data/Exercises and Examples/EX7_20.Rdata")
load("data/Exercises and Examples/EX7_20.Rdata")
data
EX7_20
library(ggplot2)
news(Version == "1.0.1", package = "ggplot2")
ggplot2(data=EX7_20, aes(x=x, y=y)) + geom_point(shape=19, size=3, color="dodgerblue")
ggplot(data=EX7_20, aes(x=x, y=y)) + geom_point(shape=19, size=3, color="dodgerblue")
EX7_20
ggplot(data=EX7_20, aes(x=X, y=Y)) +
geom_point(shape=19, size=3, color="dodgerblue")
log(e)
log(exp(1))
ggplot(data=EX7_20, aes(x= log(X), y= log(Y))) +
geom_point(shape=19, size=3, color="dodgerblue") +
title("ln(Y) = B0 + B1 * ln(X)")
labs("ln(Y) = B0 + B1 * ln(X)")
ggplot(data=EX7_20, aes(x= log(X), y= log(Y))) +
geom_point(shape=19, size=3, color="dodgerblue") +
labs("ln(Y) = B0 + B1 * ln(X)")
ggplot(data=EX7_20, aes(x= log(X), y= log(Y))) +
geom_point(shape=19, size=3, color="dodgerblue") +
ggtitle("ln(Y) = B0 + B1 * ln(X)")
log.model <- lm(log(Y) ~ log(X), data=EX7_20)
summary(log.model)
summary(lm(I(log(Y)) ~ I(log(X)), data=EX7_20))
log.model.eq <- function(x){
log.model$coef[1] + log.model$coef[2] * x
}
log.model.eq(30)
log.model.eq <- function(x){
log.model$coef[[1]] + log.model$coef[[2]] * x
}
log.model.eq(30)
exp(log.model.eq(30))
log.model.eq(exp(30)) # ln(y(30)) = B0 + B1 * ln(30)
exp(log.model.eq(exp(30)))
setwd('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/ASSIGNMENTS/A1/')
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Rfunctions.R')
options(digits = 5, show.signif.stars = FALSE)
hollyData <- read.table("Hollywood.txt", header=TRUE)
head(hollyData)
# part a) plotting with pairs()
pairs(hollyData[, c(2,3,4,1)], lower.panel = panel.smooth, upper.panel = panel.cor)
receipts.lm <- lm(Receipts ~ Production + Promo + Books, data=hollyData)
print(summary(receipts.lm))
print(anova(receipts.lm))
plot(Production, Promo, main="Relationship Between Production and Promo")
attach(hollyData)
par(mfrow=c(1,1))
plot(Production, Promo, main="Relationship Between Production and Promo")
par(mfrow=c(1,2))
# testing constant variance (plot 1) and normality of errors (plot 2)
plot(receipts2.lm, which=1:2)
receipts2.lm <- lm(Receipts ~ Production + Promo, data=hollyData)
plot(receipts2.lm, which=1:2)
setwd('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/ASSIGNMENTS/A1/')
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Rfunctions.R')
options(digits = 5, show.signif.stars = FALSE)
options(digits = 10, show.signif.stars = FALSE)
insectData <- read.table("insect.txt", header=TRUE)
head(insectData)
# part a) and b)
attach(insectData)
par(mfrow=c(1,1))
plot(Count ~ Ispray, main="Count of Surviving Insects After Each Insecticide")
max(insectData$Count[which(insectData$Ispray == "C")])
max(insectData$Count[which(insectData$Ispray == "D")])
insect.lm <- lm(Count ~ Ispray, data=insectData)
summary(insect.lm)
par(mfrow=c(1,2))
par(mfrow=c(1,2))
plot(insect.lm, which=1:2)
# must reject H0 of normality of residuals.
shapiro.test(insect.lm$residuals)
# part c) 2) Fitting the Square Root model
# (i)
insect.sqrt.lm <- lm(sqrt(Count) ~ Ispray, data=insectData)
summary(insect.sqrt.lm)
# (ii) diagnostics
par(mfrow=c(1,2))
plot(insect.sqrt.lm, which=1:2)
# Testing residuals normality - better now - we can say residuals are not
# deviating from normality.
shapiro.test(insect.sqrt.lm$residuals)
# part (iv)
summary(insect.sqrt.lm)
anova(insect.sqrt.lm)
pred <- predict(insect.sqrt.lm, newdata = data.frame(Ispray="C"),
interval="confidence", level=0.95, type="response")
pred #
sqrtInsectFit <- pred[,1]; sqrtInsectFit
# part (vi)
sqrtInsectFit^2
detach(insectData)
attach(insectData)
summary(insect.lm)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/ASSIGNMENTS/A1/Assignment1_question1.R', echo=TRUE)
par(mfrow=c(1,2))
# testing constant variance (plot 1) and normality of errors (plot 2)
plot(receipts2.lm, which=1:2)
print(summary(receipts2.lm))
shapiro.test(receipts2.lm$residuals)
insectData <- read.table("insect.txt", header=TRUE)
head(insectData)
# part a) and b)
attach(insectData)
detach(insectData)
par(mfrow=c(1,1))
plot(Count ~ Ispray, main="Count of Surviving Insects After Each Insecticide")
insect.lm <- lm(Count ~ Ispray, data=insectData)
summary(insect.lm)
# (ii) Model assumptions
par(mfrow=c(1,2))
plot(insect.lm, which=1:2)
par(mfrow=c(1,2))
plot(insect.sqrt.lm, which=1:2)
insect.lm <- lm(Count ~ Ispray, data=insectData)
summary(insect.lm)
shapiro.test(insect.lm$residuals)
insect.sqrt.lm <- lm(sqrt(Count) ~ Ispray, data=insectData)
summary(insect.sqrt.lm)
par(mfrow=c(1,2))
plot(insect.sqrt.lm, which=1:2)
# Testing residuals normality - better now - we can say residuals are not
# deviating from normality.
shapiro.test(insect.sqrt.lm$residuals)
anova(insect.sqrt.lm)
pred <- predict(insect.sqrt.lm, newdata = data.frame(Ispray="C"),
interval="confidence", level=0.95, type="response")
pred #
