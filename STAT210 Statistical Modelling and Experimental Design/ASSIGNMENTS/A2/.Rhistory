?"plot"
plot(x, pdf,  col="blue", type="l")
lines(x, cdf, type="l", col="red")
plot(x, pdf,  col="blue", type="l", ylim=c(0,1))
lines(x, cdf, type="l", col="red")
randNorm <- rnorm(n=1000, mean=101, sd=5) # units in decibels
randNorm >= 110
probNoiseGreater110 = sum(randNorm >= 110) / 1000
probNoiseGreater110
N <- 1000
sort(randNorm)
sorted <- sort(randNorm)
sorted[N * 0.95]
sorted[N * 0.95] - 105
109.2582 - 101
p = 1/2
n = 21
dbinom(seq(1, 21, by=1), size=n, prob=p)
Px <- dbinom(seq(1, 21, by=1), size=n, prob=p)
Px[11]
Px[12]
Px[7]
xs <- seq(1, 21, by=1)
Px <- dbinom(xs, size=n, prob=p)
PGTx <- pbinom(xs, size=n, prob=p, lower.tail = FALSE)
PLTx <- 1 - PGTx
PLTx
PGTx
improve <- seq(1, 21, by=1)
results <- cbind(imporve, Px, PLTx, PGTx)
pbinom(34, size=40, prob=0.5, lower.tail=FALSE)
1 - pbinom(34, size=40, prob=0.5, lower.tail=FALSE)
pbinom(34, size=40, prob=0.5, lower.tail=FALSE)
1-pbinom(33, size=40, prob=0.5, lower.tail=FALSE)
1-pbinom(33, size=40, prob=0.5, lower.tail=TRUE)
1-pbinom(34, size=40, prob=0.5, lower.tail=TRUE)
pbinom(34, size=40, prob=0.5, lower.tail=FALSE)
PGTx.2 <- 1 - pbinom(improve, size=n, prob=p, lower.tail=TRUE) # is same as above
PGTx - PGTx.2
PLTx <- 1 - PGTx
results <- cbind(improve, Px, PLTx, PGTx)
dimnames(results) <- list(NULL, c("x", "P(X = x)", "P(X <= x)", "P(X > x)"))
results
head(results, 10)
lambda = 2
p = ppois(5-1, lambda=lambda, lower.tail=FALSE)
1 - ppois(4, lambda=lambda)
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
customers <- rpois(n = 100, lambda=lambda)
customers
mean(customers)
customers[10]
hist(customers)
p.sim <- sum(customers >= 5) / 100; p.sim
p
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = 100, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / 100; p.sim
p
sim.results <- table(customers)
sim.results <- table(customers); sim.results
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = 100, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / 100; p.sim
p
sim.results <- table(customers); sim.results
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = 100, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / 100; p.sim
p
sim.results <- table(customers); sim.results
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = 100, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / 100; p.sim
p
sim.results <- table(customers); sim.results
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = 100, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / 100; p.sim
p
sim.results <- table(customers); sim.results
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = 100, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / 100; p.sim
p
sim.results <- table(customers); sim.results
1/6
2/7
sum(sim.results >= 5)
data.frame(PSim=p.sim, P=p)
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = 100, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / 100; p.sim
p
# There are 3 intervals here where at least 5 customers entered
sim.results <- table(customers); sim.results
sum(sim.results >= 5)
data.frame(PSim=p.sim, P=p)
sum(c(13, 19, 32, 17, 10,  5,  2,  2))
N <- 1000
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = N, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / N; p.sim
p
# There are 3 intervals here where at least 5 customers entered
sim.results <- table(customers); sim.results
data.frame(PSim=p.sim, P=p)
# Unlikely P(X >= 5) can suspect that mu = 2 may be greater than 2
# if indeed we think five or more customers arrive in a half minute interval
# in our observation.
N <- 1000
# Poisson lambda = 2
lambda = 2 # 2 customers per half minute
# Probability 5 or more customers in half minute interval
# These are the same:
p = ppois(5-1, lambda=lambda, lower.tail=FALSE); p
1 - ppois(4, lambda=lambda)
# Simulating arrival of 100 customers in the half minute intervals, estimate P(X >= 5)
customers <- rpois(n = N, lambda=lambda)
customers[10] # number of customers arriving in the tenth half minute interval
mean(customers) # close to 2
hist(customers)
p.sim <- sum(customers >= 5) / N; p.sim
p
# There are 3 intervals here where at least 5 customers entered
sim.results <- table(customers); sim.results
data.frame(PSim=p.sim, P=p)
# Unlikely P(X >= 5) can suspect that mu = 2 may be greater than 2
# if indeed we think five or more customers arrive in a half minute interval
# in our observation.
w <- 1:3
rbind(w, pmf.W(w))
# Question 1
pmf.W <- function(w) {
5*w / (6 * (1 + w^2))
}
# a) is valid PDF since it sums to 1
sum(pmf.W(1) + pmf.W(2) + pmf.W(3))
# and all values are positive
all(c(pmf.W(1) > 0, pmf.W(2) > 0, pmf.W(3) > 0))
# another way to check all values are positive
w <- 1:3
rbind(w, pmf.W(w))
# b) find E(W)
mu.W <- pmf.W(1) * 1 + pmf.W(2) * 2 + pmf.W(3) * 3
mu.W
# c) var(W)
# E(W^2)
mu2.W <- pmf.W(1) * 1^2 + pmf.W(2) * 2^2 + pmf.W(3) * 3^3
mu2.W
# V(W)
var.w <- mu2.W - mu.W^2
var.w
# d) TODO why not the same as above?
var.another.W <- pmf.W(1)*(1-mu.W)^2 + pmf.W(2)*(2-mu.W)^2 + pmf.W(3)*(3-mu.W)^2
var.another.W
# NUMBER 2 Integration
f.X <- function(x) { 2*(1 - x) }
# a)
integrate(f.X, 0, 1) # so is valid prob func
# b)
f.ex <- function(x) {2*x*(1-x)}
EX <- integrate(f.ex, 0, 1)
EX
names(EX)
EX$value
# c)
f.var <- function(x) { (x - EX$value)^2 * 2 * (1 - x)}
VAR.X <- integrate(f.var, 0, 1)
VAR.X$value
# NUMBER 3 Dice
# a)
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
# c)
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
df <- data.frame(diceSample)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
rbind(w, pmf.W(w))
pmf.W(w)
sum(pmf.W(w))
mu.W <- pmf.W(1) * 1 + pmf.W(2) * 2 + pmf.W(3) * 3
mu.W
w*pmf.W(w)
sum(w*pmf.W(w))
sum(w^2 * pmf.W(w)) - mu.W^2
var.w <- mu2.W - mu.W^2
var.w
var.W <- sum(w^2 * pmf.W(w)) - mu.W^2
var.W
var.W <- sum(w^2 * pmf.W(w)) - mu.W^2
var.W
var.another.W <- pmf.W(1)*(1-mu.W)^2 + pmf.W(2)*(2-mu.W)^2 + pmf.W(3)*(3-mu.W)^2
var.another.W
f.X <- function(x) { 2*(1 - x) }
# a)
integrate(f.X, 0, 1) # so is valid prob func
f.ex <- function(x) {2*x*(1-x)}
EX <- integrate(f.ex, 0, 1)
EX
names(EX)
EX$value
# c)
f.var <- function(x) { (x - EX$value)^2 * 2 * (1 - x)}
VAR.X <- integrate(f.var, 0, 1)
VAR.X$value
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
sd(diceSample)
barplot(table(diceSample))
dice1 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice2 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice3 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice1
diceSum <- dice1 + dice2 + dice3
diceSum
N <- 10^4
probLessTen <- sum(diceSum < 10) / N; probLessTen
head(dice1, dice2, dice3)
head(cbind(dice1, dice2, dice3))
df <- cbind(dice1, dice2, dice3)
df[6,]
unique(df[6,])
df[6,1] == df[6,2] == df[6,3]
df[6,1] == df[6,2] || df[6,1] == df[6,3] || df[6,2] == df[6,3]
rolls <- cbind(dice1, dice2, dice3)
c = -
c = 0
c = 0
c += 1
probFaceValuesAllDifferent
probFaceValuesAllDifferent <- count / N;
probFaceValuesAllDifferent
probFaceValuesAllDifferent <- count / N;
rolls <- cbind(dice1, dice2, dice3)
#unique(df[6,])
count <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count = count + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent <- count / N;
probFaceValuesAllDifferent
count <- 0
unique(rolls)
head(unique(rolls))
head(rolls)
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
count /
count / N
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
count / N
count <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count = count + 1
}
}
count
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
warnings()
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count = count + 1
}
}
count
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferen.1
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
assertthat::count.1 == count.2
assertthat(count.1 == count.2)
assert_that(count.1 == count.2)
count.1 == count.2
probFaceValuesAllDifferent.2
1 - pbinom(100, size=105, n = 0.10)
1 - pbinom(100, size=105, prob = 0.10)
pbinom(100, size = 105, prob = 0.10, lower.tail=FALSE)
1 - pbinom(100, size=105, prob = 0.90)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
ppois(11, lambda=10, lower.tail = FALSE)
1 - ppois(11, lambda=10)
p = ppois(11, lambda=10, lower.tail = FALSE)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
1 - pbinom(2, size=8, prob=p)
p = pgeom(2, prob=0.8, lower.tail = FALSE)
p = pgeom(2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
1 - pgeom(2, prob=0.8)
p = pgeom(q=3, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
?pgeom
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
N <- 10^4
dice1 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice2 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice3 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
diceSum <- dice1 + dice2 + dice3
# part a) Probability that sum of face values < 10
probLessTen <- sum(diceSum < 10) / N; probLessTen
rolls <- cbind(dice1, dice2, dice3)
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
probFaceValuesAllDifferent.2
# Test to make sure: Should be true, the two methods yield the same answer.
count.1 == count.2
1 - pbinom(100, size=105, prob = 0.90)
# method 2 of calculating
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Assignment2_questions_1_4_5.R', echo=TRUE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
1 - ppois(11, lambda=10)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
# method 2
1 - ppois(11, lambda=10)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
# method 2
1 - pbinom(2, size=8, prob=p)
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
# Method 2
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
# Method 2
1 - pbinom(3, size=10, prob=p)
p = pgeom(q=0, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(2, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(0, prob=0.8) # P(X >= 2) = P(X <= 1)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/ASSIGNMENTS/A2/")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Rfunctions.R')
library(MASS)
options(digits=10, show.signif.stars = F)
# part a)
insectData <- read.table("insect.txt", header=TRUE)
# choosing only the rows without the Count = 0
insectData.NoZero <- insectData[insectData$Count != 0, ]
# part b)
insect.sqrt.lm <- lm(sqrt(Count) ~ Ispray, data=insectData.NoZero)
boxcox(Count ~ Ispray, , data=insectData.NoZero, lambda=seq(from=0, to=1, by=0.01))
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/ASSIGNMENTS/A2/")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Rfunctions.R')
library(ggplot2)
library(ggplot2)
options(digits=10, show.signif.stars = F)
data("ToothGrowth")
ToothGrowth$dose <- factor(ToothGrowth$dose)
attach(ToothGrowth)
formLower <- formula(~ 1)
formUpper <- formula( ~ dose * supp, data=ToothGrowth)
start.model <- lm(len ~ 1, data=ToothGrowth)
step.forward.model <- step(start.model, direction = "forward",
scope=list(lower=formLower, upper=formUpper))
summary(step.forward.model)
interaction.plot(x.factor=dose, trace.factor = supp, response=len)
