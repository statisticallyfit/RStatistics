pmf.W <- function(w) {
5*w / (6 * (1 + w^2))
}
# a) is valid PDF since it sums to 1
sum(pmf.W(1) + pmf.W(2) + pmf.W(3))
# and all values are positive
all(c(pmf.W(1) > 0, pmf.W(2) > 0, pmf.W(3) > 0))
# another way to check all values are positive
w <- 1:3
rbind(w, pmf.W(w))
# b) find E(W)
mu.W <- pmf.W(1) * 1 + pmf.W(2) * 2 + pmf.W(3) * 3
mu.W
# c) var(W)
# E(W^2)
mu2.W <- pmf.W(1) * 1^2 + pmf.W(2) * 2^2 + pmf.W(3) * 3^3
mu2.W
# V(W)
var.w <- mu2.W - mu.W^2
var.w
# d) TODO why not the same as above?
var.another.W <- pmf.W(1)*(1-mu.W)^2 + pmf.W(2)*(2-mu.W)^2 + pmf.W(3)*(3-mu.W)^2
var.another.W
# NUMBER 2 Integration
f.X <- function(x) { 2*(1 - x) }
# a)
integrate(f.X, 0, 1) # so is valid prob func
# b)
f.ex <- function(x) {2*x*(1-x)}
EX <- integrate(f.ex, 0, 1)
EX
names(EX)
EX$value
# c)
f.var <- function(x) { (x - EX$value)^2 * 2 * (1 - x)}
VAR.X <- integrate(f.var, 0, 1)
VAR.X$value
# NUMBER 3 Dice
# a)
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
# c)
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
df <- data.frame(diceSample)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
rbind(w, pmf.W(w))
pmf.W(w)
sum(pmf.W(w))
mu.W <- pmf.W(1) * 1 + pmf.W(2) * 2 + pmf.W(3) * 3
mu.W
w*pmf.W(w)
sum(w*pmf.W(w))
sum(w^2 * pmf.W(w)) - mu.W^2
var.w <- mu2.W - mu.W^2
var.w
var.W <- sum(w^2 * pmf.W(w)) - mu.W^2
var.W
var.W <- sum(w^2 * pmf.W(w)) - mu.W^2
var.W
var.another.W <- pmf.W(1)*(1-mu.W)^2 + pmf.W(2)*(2-mu.W)^2 + pmf.W(3)*(3-mu.W)^2
var.another.W
f.X <- function(x) { 2*(1 - x) }
# a)
integrate(f.X, 0, 1) # so is valid prob func
f.ex <- function(x) {2*x*(1-x)}
EX <- integrate(f.ex, 0, 1)
EX
names(EX)
EX$value
# c)
f.var <- function(x) { (x - EX$value)^2 * 2 * (1 - x)}
VAR.X <- integrate(f.var, 0, 1)
VAR.X$value
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
sd(diceSample)
barplot(table(diceSample))
dice1 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice2 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice3 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice1
diceSum <- dice1 + dice2 + dice3
diceSum
N <- 10^4
probLessTen <- sum(diceSum < 10) / N; probLessTen
head(dice1, dice2, dice3)
head(cbind(dice1, dice2, dice3))
df <- cbind(dice1, dice2, dice3)
df[6,]
unique(df[6,])
df[6,1] == df[6,2] == df[6,3]
df[6,1] == df[6,2] || df[6,1] == df[6,3] || df[6,2] == df[6,3]
rolls <- cbind(dice1, dice2, dice3)
c = -
c = 0
c = 0
c += 1
probFaceValuesAllDifferent
probFaceValuesAllDifferent <- count / N;
probFaceValuesAllDifferent
probFaceValuesAllDifferent <- count / N;
rolls <- cbind(dice1, dice2, dice3)
#unique(df[6,])
count <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count = count + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent <- count / N;
probFaceValuesAllDifferent
count <- 0
unique(rolls)
head(unique(rolls))
head(rolls)
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
count /
count / N
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
count / N
count <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count = count + 1
}
}
count
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
warnings()
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count = count + 1
}
}
count
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferen.1
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
assertthat::count.1 == count.2
assertthat(count.1 == count.2)
assert_that(count.1 == count.2)
count.1 == count.2
probFaceValuesAllDifferent.2
1 - pbinom(100, size=105, n = 0.10)
1 - pbinom(100, size=105, prob = 0.10)
pbinom(100, size = 105, prob = 0.10, lower.tail=FALSE)
1 - pbinom(100, size=105, prob = 0.90)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
ppois(11, lambda=10, lower.tail = FALSE)
1 - ppois(11, lambda=10)
p = ppois(11, lambda=10, lower.tail = FALSE)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
1 - pbinom(2, size=8, prob=p)
p = pgeom(2, prob=0.8, lower.tail = FALSE)
p = pgeom(2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
1 - pgeom(2, prob=0.8)
p = pgeom(q=3, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
?pgeom
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
N <- 10^4
dice1 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice2 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice3 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
diceSum <- dice1 + dice2 + dice3
# part a) Probability that sum of face values < 10
probLessTen <- sum(diceSum < 10) / N; probLessTen
rolls <- cbind(dice1, dice2, dice3)
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
probFaceValuesAllDifferent.2
# Test to make sure: Should be true, the two methods yield the same answer.
count.1 == count.2
1 - pbinom(100, size=105, prob = 0.90)
# method 2 of calculating
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Assignment2_questions_1_4_5.R', echo=TRUE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
1 - ppois(11, lambda=10)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
# method 2
1 - ppois(11, lambda=10)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
# method 2
1 - pbinom(2, size=8, prob=p)
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
# Method 2
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
# Method 2
1 - pbinom(3, size=10, prob=p)
p = pgeom(q=0, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(2, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(0, prob=0.8) # P(X >= 2) = P(X <= 1)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/PRACTICALS/Practical_4_MapleSamara/Pratical4_MapleSamara.R', echo=TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/ASSIGNMENTS/A2/Question1_toothgrowth.R', echo=TRUE)
start.model <- lm(len ~ 1, data=ToothGrowth)
formLower <- formula(~ 1)
formUpper <- formula( ~ dose * supp, data=ToothGrowth)
step.forward.model <- lm(len ~ dose * supp, data=ToothGrowth)
step.forward.model <- step(start.model, direction = "forward",
scope=list(lower=formLower, upper=formUpper))
start.model <- lm(len ~ 1, data=ToothGrowth)
step.forward.model <- step(start.model, direction = "forward",
scope=list(lower=formLower, upper=formUpper))
anova(step.forward.model)
summary(step.forward.model)
betas <- summary(step.forward.model)$coef
betas
betas <- summary(step.forward.model)$coef[,1]
betas
betas <- betaCI(step.forward.model)
betas
betas <- summary(step.forward.model)$coef[,1]
betas
betas[1] + B[3]
betas[1] + betas[3]
View(ToothGrowth)
predict(step.forward.model, newdata=data.frame(dose="2", supp="OJ"), type="response")
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/ASSIGNMENTS/A2/")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Rfunctions.R')
options(digits=10, show.signif.stars = F)
InsectSprays
insectData <- read.table("insect.txt", header=TRUE)
nrow(insectData)
insect.sqrt.lm <- lm(sqrt(Count) ~ Ispray, data=insectData)
insectData
which(insectData$Count == 0)
insectData$Count == 0
insectData[insectData$Count == 0, ]
insectData[insectData$Count != 0, ]
nrow(insectData[insectData$Count != 0, ])
insectData.NoZero <- insectData[insectData$Count != 0, ]
?boxcox
insect.sqrt.lm <- lm(sqrt(Count) ~ Ispray, data=insectData.NoZero)
boxcox(insect.sqrt.lm)
boxcox_trans(insect.sqrt.lm)
library(MASS)
library(MASS)
options(digits=10, show.signif.stars = F)
boxcox(Count ~ Ispray, lambda=seq(from=0, to=1, by=0.01))
attach(insectData.NoZero)
boxcox(Count ~ Ispray, lambda=seq(from=0, to=1, by=0.01))
library(car)
boxCox(Count ~ Ispray, lambda=seq(from=0, to=1, by=0.01))
?boxCox
boxCox(Count ~ Ispray, lambda=seq(from=0, to=1, by=0.01))
boxcox(Count ~ Ispray, lambda=seq(from=0, to=1, by=0.01))
b <- boxcox(Count ~ Ispray, lambda=seq(from=0, to=1, by=0.01))
b
detach(insectData.NoZero)
detach(insectData.NoZero)
boxcox(Count ~ Ispray, , data=insectData.NoZero, lambda=seq(from=0, to=1, by=0.01))
bloodData <- read.table("bloodflow.txt", header=TRUE)
bloodData
View(bloodData)
library(ggplot2)
options(digits=10, show.signif.stars = F)
bloodData <- read.table("bloodflow.txt", header=TRUE)
ggplot(bloodData, aes(x=AOT, y=BF)) +
geom_point(shape=19, size=3, color="dodgerblue")
ggplot(bloodData, aes(x=AOT, y=BF)) +
geom_point(shape=19, size=3, color="dodgerblue") +
ggtitle("Scatterplot of Arterial Oxygen Tension (AOT) against Bloodflow (BF)")
bflowData <- read.table("bloodflow.txt", header=TRUE)
bflow.2.lm <- lm(BF ~ AOT + I(AOT^2), data=bflowData)
anova(bflow.2.lm)
bflow.3.lm <- update(bflow.2.lm, .~. + I(AOT^3), data=bflowData)
bflow.3.lm
lm(BF ~ AOT + I(AOT^2) + I(AOT^3), data=bflowData)
anova(bflow.3.lm)
bflow.1.lm <- lm(BF ~ AOT, data=bflowData)
anova(bflow.1.lm)
View(bflowData)
anova(update(bflow.3.lm, .~. + I(AOT^4), data=bflowData))
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 3 - Simple Linear Regression/")
options(digits=10, show.signif.stars = FALSE)
source("../Rfunctions.r")
dat1 <- read.table("worksheet1_data.txt", header=TRUE)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 3 - Simple Linear Regression/")
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/PRACTICALS/Worksheet_Chapter3_ODP_SRP/")
dat1 <- read.table("worksheet1_data.txt", header=TRUE)
head(dat1)
attach(dat1)
xy.lm <- lm(ODP ~ SRP, data=dat1)
# Plot data and fitted line
plot(ODP ~ SRP, data=dat1, ylab="oxygen demand percent", xlab="solids reduction percent")
abline(xy.lm)
# Question 1: association seems strong, positive linear relation between x and y.
pred.df <- data.frame(SRP=c(10,20,30,40,50,60,70,80))
CI <- predict(xy.lm, interval="confidence", newdata=pred.df)
PI <- predict(xy.lm, interval="predict", newdata=pred.df)
cbind(pred.df$SRP, CI, PI)
nrow(dat1)
par(mfrow=c(1,1))
plot(pred.df$SRP, CI[,1], type="b", pch=16, xlab="SRP", ylab="mean ODP",
main="Scatterplot of ODP ~ SRP, with predicted values and 95%
confidence and prediction abnds")
points(dat1$ODP, dat1$SRP)
legend(10, 50, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
legend(10, 42, pch=c(1,16), legend=c("observed values", "predicted values"))
lines(pred.df$SRP, CI[,2], lty=2) # lty = linetype, lty = 2 is dashed
# upr CI
lines(pred.df$SRP, CI[,3], lty=2)
# lwr PI
lines(pred.df$SRP, PI[,2], lty=3) # pred intervals always wider than CIs
# upr PI
lines(pred.df$SRP, PI[,3], lty=3)
range(bflowData$AOT )
AOT
from = min(bflowData$AOT)
to = max(bflowData$AOT)
n <- nrow(bflowData)
pred.df <- data.frame(AOT_Values=seq(from=from,to=to, len=n))
pred.df
CI <- predict(bflow.2.lm, interval="confidence", newdata=pred.df)
pred.df <- data.frame(AOT=seq(from=from,to=to, len=n))
CI <- predict(bflow.2.lm, interval="confidence", newdata=pred.df)
PI <- predict(bflow.2.lm, interval="predict", newdata=pred.df)
cbind(pred.df$AOT, CI, PI)
pred.df <- cbind(pred.df$AOT, CI, PI)
colnames(pred.df) <- c("AOT", colnames(pred.df))
preds <- data.frame(AOT=seq(from=from,to=to, len=n))
CI <- predict(bflow.2.lm, interval="confidence", newdata=pred.df)
CI <- predict(bflow.2.lm, interval="confidence", newdata=preds)
PI <- predict(bflow.2.lm, interval="predict", newdata=preds)
pred.df <- data.frame(AOT=preds$AOT, CI, PI)
pred.df
par(mfrow=c(1,1))
CI
plot(pred.df$AOT, CI[,1], type="b", pch=16, xlab="AOT", ylab="mean Bloodflow",
main="Scatterplot of Bflow ~ AOT, with predicted values and 95%
confidence and prediction bands")
points(bflowData$AOT, bflowData$BF)
legend(450,83, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
legend(390,83, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
legend(360,84, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
par(mfrow=c(1,1))
plot(pred.df$AOT, CI[,1], type="b", pch=16, xlab="AOT", ylab="mean Bloodflow",
main="Scatterplot of Bflow ~ AOT, with predicted values and 95%
confidence and prediction bands")
points(bflowData$AOT, bflowData$BF)
legend(360,84, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
legend(360, 81, pch=c(1,16), legend=c("observed values", "predicted values"))
plot(pred.df$AOT, CI[,1], type="b", pch=16, xlab="AOT", ylab="mean Bloodflow",
main="Scatterplot of Bflow ~ AOT, with predicted values and 95%
confidence and prediction bands")
points(bflowData$AOT, bflowData$BF)
legend(360,84, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
legend(360, 81, pch=c(1,16), legend=c("observed values", "predicted values"))
plot(pred.df$AOT, CI[,1], type="b", pch=16, xlab="AOT", ylab="mean Bloodflow",
main="Scatterplot of Bflow ~ AOT, with predicted values and 95%
confidence and prediction bands")
points(bflowData$AOT, bflowData$BF)
legend(360,84, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
legend(400, 82, pch=c(1,16), legend=c("observed values", "predicted values"))
lines(pred.df$SRP, CI[,2], lty=2) # lty = linetype, lty = 2 is dashed
lines(pred.df$AOT, CI[,2], lty=2) # lty = linetype, lty = 2 is dashed
min(c(1,2,3), c(3,4,5))
min(c(1,2,3), c(3,4,5,-1))
pred.df
CI
class(CI)
CI <- data.frame(predict(bflow.2.lm, interval="confidence", newdata=preds))
CI
PI <- data.frame(predict(bflow.2.lm, interval="predict", newdata=preds))
pred.df <- data.frame(AOT=preds$AOT, fit=CI$fit, CI.lower=CI$lwr, CI.upper=CI$upr,
PI.lower=PI$lwr, PI.upper=PI$upr)
pred.df
allLower = c(pred.df$CI.lower, pred.df$PI.lower)
allLower
allUpper = c(pred.df$CI.upper, pred.df$PI..upper)
allUpper = c(pred.df$CI.upper, pred.df$PI.upper)
allUpper
plot(BF ~ AOT, data=bflowData, ylim = c(min(allLower), max(allUpper)))
plot(pred.df$AOT, pred.df$fit, type="b", pch=16, xlab="AOT", ylab="mean Bloodflow",
main="Scatterplot of Bflow ~ AOT, with predicted values and 95%
confidence and prediction bands")
points(BF, AOT, data=bflowData, ylim = c(min(allLower), max(allUpper)))
points(bflowData$BF, bflowData$AOT, ylim = c(min(allLower), max(allUpper)))
points(bflowData$AOT, bflowData$BF, ylim = c(min(allLower), max(allUpper)))
legend(360,84, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
legend(400, 82, pch=c(1,16), legend=c("observed values", "predicted values"))
lines(pred.df$AOT, pred.df$CI.lower, lty=2) # lty = linetype, lty = 2 is dashed
# upr CI
par(mfrow=c(1,1))
plot(pred.df$AOT, pred.df$fit, type="b", pch=16, xlab="AOT", ylab="mean Bloodflow",
main="Scatterplot of Bflow ~ AOT, with predicted values and 95%
confidence and prediction bands", ylim = c(min(allLower), max(allUpper)))
allLower = c(pred.df$CI.lower, pred.df$PI.lower)
allUpper = c(pred.df$CI.upper, pred.df$PI.upper)
points(bflowData$AOT, bflowData$BF)
legend(360,84, lty=c(1, 2, 3), legend=c("Line of best fit",
"95% Confidence Bands",
"95% Prediction Bands"))
legend(400, 82, pch=c(1,16), legend=c("observed values", "predicted values"))
# lwr CI
lines(pred.df$AOT, pred.df$CI.lower, lty=2) # lty = linetype, lty = 2 is dashed
# upr CI
lines(pred.df$AOT, pred.df$CI.upper, lty=2)
# lwr PI
lines(pred.df$AOT, pred.df$PI.lower, lty=3) # pred intervals always wider than CIs
# upr PI
lines(pred.df$AOT, pred.df$PI.upper, lty=3)
library(ggfortify)
autoplot(bflow.2.lm, which=1:2, color="navy", size=4)
autoplot(bflow.2.lm, which=1:2, color="purple", size=4)
shapiro.test(bflow.2.lm$residuals)
autoplot(bflow.2.lm, which=1:2)
