x <- runif(n=10000, min=0, max=1)
gx <- exp(x)
mean(gx)
estimateOfE = mean(gx) + 1
estimateOfE
n <- 10000
x <- runif(n=n, min=0, max=1)
gx <- exp(x)
mean(gx)
estimateOfE = mean(gx) + 1
estimateOfE
(1/n)*sum(exp(x))
hx <- 1 / (1 + x^2)
mean(hx)
mean(hx)*4
simE <- 0 # store estimates of E
simPi <- 0 # store estimates of pi
# num samples
n <- 1000
for(i in 1:1000){
# gnerate sample of size n from Unif(0,1)
us <- runif(n, min=0, max=1)
EXPECT_eX <- (1/n)*sum(exp(us)) + 1
EeX <- (1/n)*sum(exp(us))
e <- 1 + Eex
simE[i] = e
# find E[1 / (1+x^2)]
EhX <- (1/n) * sum(1 / (1 + us^2))
# hx = arctan(1) = pi/4
pie <- EhX * 4
simPi[i] <- pie
}
for(i in 1:1000){
# gnerate sample of size n from Unif(0,1)
us <- runif(n, min=0, max=1)
EeX <- (1/n)*sum(exp(us))
e <- 1 + EeX
simE[i] = e
# find E[1 / (1+x^2)]
EhX <- (1/n) * sum(1 / (1 + us^2))
# hx = arctan(1) = pi/4
pie <- EhX * 4
simPi[i] <- pie
}
df <- data.frame(simE=simE, simPi=simPi)
df.melt <- melt(df)
df.melt
x <- data.frame(v1=rnorm(100),v2=rnorm(100,1,1),v3=rnorm(100,0,2))
m <- melt(x)
head(m)
m <- melt(x, id="")
df <- data.frame(simE=simE, simPi=simPi)
df.melt <- melt(df)
ggplot(df, aes(x=value, fill=variable)) + geom_density(alpha=0.2)
ggplot(df.melt, aes(x=value, fill=variable)) + geom_density(alpha=0.2)
ggplot(df.melt, aes(x=value, colour=variable)) + geom_density(size=1)
ggplot(df.melt, aes(x=value, colour=variable)) + geom_density(size=1)
mean(simPi)
mean(simE)
x <- seq(0, 10, by=0.01)
gamma1 <- dgamma(x=x, shape=2, scale=1)
gamma2 <- dgamma(x, shape=3, scale=1)
gamma3 <- dgamma(x, shape=4, scale1)
gamma3 <- dgamma(x, shape=4, scale=1)
gsList <- list(gamma1, gamma2, gamma3)
plotMultipleContinuousDist(x, gsList)
paste(alpha)
expression(paste(alpha))
leg.txt <- c(expression(paste("Gamma","(",alpha, "=","2",",",beta,"=",1,")")),
expression(paste("Gamma","(",alpha, "=","3",",",beta,"=",1,")")),
expression(paste("Gamma","(",alpha, "=","4",",",beta,"=",1,")")))
plot(x, gamma1, type="l", ylim=c(0,0.4), ylab="Density", main="Gamma Densities",las =1)
lins(x, gamma2, col=2)
lines(x, gamma2, col=2)
lines(x, gamma3, col=3)
legend(x=5.5, y=0.3, legend=leg.txt, fill=c(1,2,3))
randGamma <- rgamma(1000, shape=2, scale=3) # alpha=2, beta=3
mean(randGamma)
var(randGamma) # V(X) = a*b^2 = 2*9=18
qnorm(0.20, mean=0, sd=1)
qnorm(0.10, mean=0, sd=1)
pnorm(-1.3)
1.281552-0.8416212
-15/0.4399308
1.281552/0.8416212
20*1.281552/0.8416212-35
-4.545634/1.522718
qnorm(0.10, mean=0, sd=1, lower.tail=F)
qnorm(1 - 0.10, mean=0, sd=1) # another way
qnorm(0.20, mean=0, sd=1)
z0 <- qnorm(0.20, mean=0, sd=1)
z1 <- qnorm(0.10, mean=0, sd=1, lower.tail=F)
z0 <- qnorm(0.20, mean=0, sd=1); z0
z1 <- qnorm(0.10, mean=0, sd=1, lower.tail=F); z1
qexp(p=0.25, rate=1/40)
pexp(2, rate=9/4, lower.tail=F)
1 - pexp(2, rate=9/4)
ppois(2, lambda=9/4, lower.tail=F)
1 - ppois(2, lambda=9/4)
beta = 40
qexp(p=0.25, rate=1/beta)
pexp(90, rate=1/beta, lower.tail=F)
diff(pexp(c(10,20), rate=1/beta)) / pexp(10, rate=1/beta, lower.tail=F)
pexp(10, rate=1/beta)
pexp(10, rate=1/beta)
pbinom(0, size=5, p=pexp(10, rate=1/beta))
pbinom(0, size=5, p=pexp(10, rate=1/beta), lower.tail=FALSE)
p = pexp(10, rate=1/beta)
pbinom(0, size=5, p=p, lower.tail=FALSE)
1 - dbinom(0, size=5, p=p)
p = pexp(10, rate=1/beta, lower.tail=FALSE)
pbinom(0, size=5, p=p, lower.tail=FALSE)
1 - dbinom(0, size=5, p=p)
p = pexp(90, rate=1/beta, lower.tail=FALSE)
pbinom(0, size=5, p=p, lower.tail=FALSE)
1 - dbinom(0, size=5, p=p)
z0 <- qnorm(0.20, mean=0, sd=1); z0
z1 <- qnorm(0.10, mean=0, sd=1, lower.tail=F); z1
qnorm(1 - 0.10, mean=0, sd=1) # another way
pgamma(30000,shape=20,scale=1000,lower.tail=F)
integrate(function(x){(1/(1000^20)*gamma(20)) * x^(20-1) *exp(-x/1000) }, lower=30000, upper=Inf)
pgamma(30,000, shape=20, scale=1000, lower.tail=F) #
pgamma(30000, shape=20, scale=1000, lower.tail=F) #
gamma(2)
gamma(4)
gamma(5)
integrate(function(x){(1/(1000^20 * gamma(20))) * x^(20-1) *exp(-x/1000) }, lower=30000, upper=Inf)
gamma.density <- function(x){(1/(1000^20 * gamma(20))) * x^(20-1) *exp(-x/1000) }
integrate(gamma.density, lower=30000, upper=Inf)
pgamma(30000, shape=20, scale=1000, lower.tail=FALSE)
gamma(20)
factorial(19)
qexp(p=0.25, rate=1/beta)
pexp(90, rate=1/beta, lower.tail=F)
pexp(10, rate=1/beta)
diff(pexp(c(10,20), rate=1/beta)) / pexp(10, rate=1/beta, lower.tail=F)
p2 = pexp(10, rate=1/beta, lower.tail=F) # P (T > 10)
p1 / p2
p1 = diff(pexp(c(10,20), rate=1/beta)) # P(10 < T < 20)
p1 / p2
pexp(10, rate=1/beta)
ppois(2, lambda=9/4, lower.tail=F)
1 - ppois(2, lambda=9/4) # another way to calculate
p = pexp(90, rate=1/beta, lower.tail=FALSE)
pbinom(0, size=5, p=p, lower.tail=FALSE)
p = pexp(90, rate=1/beta, lower.tail=FALSE); p
pbinom(0, size=5, p=p, lower.tail=FALSE)
1 - dbinom(0, size=5, p=p)
diff(pbinom(c(145, 163), size=600, p=0.25))
diff(pbinom(c(144, 163), size=600, p=0.25))
diff(pnorm(c(144.5, 163.5), mean=600*0.25, sd=sqrt(600*0.25*0.75)))
n=10^5
X = runif(n=n, min=0, max=1)
Y = runif(n=n, min=0, max=1)
head(X)
probBothBetweenHalf <- sum((X <= 0.5) & (Y <= 0.5))/n
probBothBetweenHalf
n = 500 # sample of size 500 from bivariate uniform.
u1 <- runif(n=n, min=0, max=1)
u2 <- runif(n=n, min=0, max=1)
# logical vec depending on whether conditions are met
logicBothBetweenHalf <- (u1 < 05.) & (u2 < 0.5)
logicBothBetweenHalf
probBothBetweenHalf <- sum((u1 < 05.) & (u2 < 0.5))
probBothBetweenHalf
probBothBetweenHalf <- sum((u1 < 05.) & (u2 < 0.5)) / n
probBothBetweenHalf
theSim <- 0
library(reshape2)
theSim <- 0
# repeat sampling 1000 times
for(i in 1:1000) {
n = 500 # sample of size 500 from bivariate uniform.
u1 <- runif(n=n, min=0, max=1)
u2 <- runif(n=n, min=0, max=1)
# logical vec depending on whether conditions are met
probBothBetweenHalf <- sum((u1 < 05.) & (u2 < 0.5)) / n
#store result from each sample (i)
theSim[i] = probBothBetweenHalf
}
theSim
melt(data)
data <- melt(data.frame(theSim))
data
head(data)
ggplot(data, aes(y=value)) + geom_density()
library(ggpl2)
Library(ggplot2)
library(ggplot2)
ggplot(data, aes(y=value)) + geom_density()
data <- data.frame(theSim)
ggplot(data, aes(x=theSim)) + geom_density()
ggplot(data, aes(x=theSim)) + geom_density(size=2, colour="hotpink")
ggplot(data, aes(x=theSim)) + geom_histogram()
ggplot(data, aes(x=theSim)) + geom_histogram(colour="hotpink")
ggplot(data, aes(x=theSim)) + geom_histogram(fill="hotpink")
ggplot(data, aes(x=theSim)) + geom_histogram(fill="lightpink")
theSim <- 0
# repeat sampling 1000 times
for(i in 1:1000) {
n = 500 # sample of size 500 from bivariate uniform.
u1 <- runif(n=n, min=0, max=1)
u2 <- runif(n=n, min=0, max=1)
# logical vec depending on whether conditions are met
probBothBetweenHalf <- sum((u1 < 05.) & (u2 < 0.5)) / n
#store result from each sample (i)
theSim[i] = probBothBetweenHalf
}
library(ggplot2)
data <- data.frame(theSim)
ggplot(data, aes(x=theSim)) + geom_density(size=2, colour="hotpink")
ggplot(data, aes(x=theSim)) + geom_histogram(fill="lightpink")
sampleSize <- 10^4
die1 <- sample(x=1:6, size=sampleSize, replace=TRUE) # each prob = 1/6
die2 <- sample(x=1:6, size=sampleSize, replace=TRUE) # each prob = 1/6
jointProb <- table(die1, die2)/sampleSize
jointProb
table(die1, die2)
jointProb[5:6]
jointProb[5:6]
fives <- (die1 == 5) + (die2==5)
sixes <- (die1 == 6) + (die2 == 6)
jointProb56 <- table(fives, sixes)/sampleSize
jointProb56
diag(table(die1, die2)[5:6]/sampleSize)
jointProb[5:6] # this is the joint probability of
diag(table(die1, die2))[5:6]/sampleSize
jointProb56
prob56 <- diag(table(die1, die2))[5:6]/sampleSize
jointProb56
jointProb56
jointProb56[3,1]
jointProb56[1,3]
(2/3)^2
mu_I = 29.87
mu_C = 31.77
sd_I=7.71
sd_C = 7.86
p = 0.957
# part d) pdf of Canandaigua temperature (had muC, varC)
lower <- mu_C - 4 * sd_C
upper <- mu_C + 4 * sd_C
xs <- seq(lower, upper, length=10^3)
ys = dnorm(x=xs, mean=mu_C, sd=sd_C)
df <- data.frame(xs=xs, ys=ys)
ggplot() +
geom_line(data=df, aes(x=xs, y=ys), size=1, colour="blue") +
geom_vline(xintercept=mu_C, colour="black", linetype="dashed", size=1) +
ggtitle("Normal Density of Canandaigua Max Temperature")
mu_C_given_I <- function(i) mu_C + p * (sd_C/sd_I) * (i - mu_I)
sd_C_given_I <- sd_C^2 * (1 - p^2)
df.cond <- data.frame(xs=xs, ys=dnorm(x=xs, mean=mu_C_given_I(25), sd=sd_C_given_I))
ggplot() +
geom_line(data=df.cond, aes(x=xs, y=ys), size=1, colour="red") +
geom_vline(xintercept=mu_C_given_I(25), colour="black", linetype="dashed",
size=1) +
ggtitle("Conditional Normal PDF of Canadaigua given Ithaca = 25 degrees F")
x1 <- x2 <- seq(0, 1, length=128)
x1
x2
const <- 6/5
var.grid <- expand.grid("x1", =x1, "x2"=x2)# create grid of bivarate rvs
var.grid <- expand.grid("x1" =x1, "x2"=x2)# create grid of bivarate rvs
var.grid
X1 <- var.grid$x1
X2 <- var.grid$x2
X2
?expand.grid
x <- seq(0, 10, length.out = 100)
y <- seq(-1, 1, length.out = 20)
d1 <- expand.grid(x = x, y = y)
length(x)
length(y)
d1
head(d1)
head(d1, 103)
jointPDF <- const * (X1 + X2^2)
jointPDF
jointPDF <- matrix(jointPDF, ncol=128, nrow=128)
jointPDF
x11()
jointPDF # typecast as matrix.
x11()
persp(z=jointPDF, y=x1, x=x2, col="lightblue") # perspective plot
x11()
image(jointPDF, xlab="x1", ylab="x2", col=heat.colors(256))
# image view
axis(side=1, at = seq(0,1,by=0.2), labels=seq(0,1,length=6))
axis(side=2, at = seq(0,1,by=0.2), labels=seq(0,1,length=6))
contour(jointPDF, nlevels=10, add=TRUE)
indices <- which(X1 <= 0.5 & X2 <= 0.5)
indices
head(indices)
head(indices, 20)
regionOfInterest <- jointPDF[indices]
regionOfInterest
prob <- sum(regionOfInterest * (1/128^2)) # calculate probability using a riemann sum.
prob
N <- 128
oddsRatio(admitTable)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/FORMULAS.R', echo=TRUE)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 9 - Logistic Regression/")
honorsData <- read.table("honors.txt", header=TRUE)
freq <- rbind(table(honorsData$hon),
100*table(honorsData$hon)/nrow(honorsData))
freq <- data.frame(freq)
colnames(freq) <- c("No", "Honors")
rownames(freq) <- c("Freq", "Percent")
freq <- t(freq)
tab <- table(honorsData$hon, honorsData$female)
colnames(tab) <- c("Male", "Female")
rownames(tab) <- c("No", "Honors")
m.tab <- marginalTable(tab); m.tab
oddsRatio(tab)
oddsRatio(tab) - 1
oddsMales <- tab[2,1]/tab[1,1]; oddsMales
oddsFem <- tab[2,2] / tab[1,2]; oddsFem # odds for females being in honors class
oddsFem/oddsMales
1/oddsRatio(tab)
rowOdds(tab)
2.40625004.3529412/
4.3529412/2.4062500
0.4155844/0.2297297
tab#
74/14
714/17
74/17
tab#
77/32
rowOdds(tab)
library(DescTools)
OddsRatio(tab)
OddsRatio(admitTable)
admitTable <- as.table(matrix(c(1198, 1493, 557, 1278), byrow=TRUE,nrow=2))
colnames(admitTable) <- c("Admitted", "Rejected")
rownames(admitTable) <- c("Male", "Female")
admitTable
OddsRatio(admitTable)
oddsRatio(admitTable)
rowOdds(admitTable)
rowOdds(t(admitTable))
0.8024113/0.4358372
1.2462437/2.2944345
1/0.543
rowOdds(tab)
oddsFem <- tab[2,2] / tab[1,2]; oddsFem # odds for females being in honors class
oddsMales <- tab[2,1]/tab[1,1]; oddsMales
oddsRatio.r <- function(tbl) {
### make names combos
combosColnames <- combn(colnames(tbl), m=2)
combosColnames <- paste(combosColnames[1,], "/", combosColnames[2,], sep="")
combosRownames <- combn(rownames(tbl), m=2)
combosRownames <- paste(combosRownames[1, ], "/", combosRownames[2,], sep="")
### make odds for each col, holding rows constant
combosRow <- lapply(1:ncol(tbl), function(i) combn(tbl[,i], m=2))
rOdds <- lapply(1:ncol(tbl), function(i){combosRow[[i]][1, ] / combosRow[[i]][2, ]})
library(plyr)
rOdds <- ldply(rOdds)
colnames(rOdds) <- colnames(tbl)
rownames(rOdds) <- combosRownames(tbl)
oddsPairs <- lapply(1:nrow(rOdds), function(i) combn(rOdds[i,], m=2))
oddsRatios <- lapply(1:nrow(rOdds), function(i) {oddsPairs[[i]][1,] / oddsPairs[[i]][2,]})
oddsRatios <- t(ldply(oddsRatios))
colnames(oddsRatios) <- combosColnames
rownames(oddsRatios) <- combosRownames
return(oddsRatios)
}
oddsRatio.r(tab)
oddsRatio.r <- function(tbl) {
### make names combos
combosColnames <- combn(colnames(tbl), m=2)
combosColnames <- paste(combosColnames[1,], "/", combosColnames[2,], sep="")
combosRownames <- combn(rownames(tbl), m=2)
combosRownames <- paste(combosRownames[1, ], "/", combosRownames[2,], sep="")
### make odds for each col, holding rows constant
combosRow <- lapply(1:ncol(tbl), function(i) combn(tbl[,i], m=2))
rOdds <- lapply(1:ncol(tbl), function(i){combosRow[[i]][1, ] / combosRow[[i]][2, ]})
library(plyr)
rOdds <- t(ldply(rOdds))
colnames(rOdds) <- colnames(tbl)
rownames(rOdds) <- combosRownames(tbl)
oddsPairs <- lapply(1:nrow(rOdds), function(i) combn(rOdds[i,], m=2))
oddsRatios <- lapply(1:nrow(rOdds), function(i) {oddsPairs[[i]][1,] / oddsPairs[[i]][2,]})
oddsRatios <- t(ldply(oddsRatios))
colnames(oddsRatios) <- combosColnames
rownames(oddsRatios) <- combosRownames
return(oddsRatios)
}
oddsRatio.r(tab)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/FORMULAS.R', echo=TRUE)
oddsRatio.r(tab)
tbl <- tab#
C
combosColnames <- combn(colnames(tbl), m=2)
combosColnames
combosColnames <- paste(combosColnames[1,], "/", combosColnames[2,], sep="")
combosRownames <- combn(rownames(tbl), m=2)
combosRownames
combosRownames <- paste(combosRownames[1, ], "/", combosRownames[2,], sep="")
combosCol <- lapply(1:nrow(tbl), function(i) combn(tbl[i,], m=2))
combosCol
cOdds <- lapply(1:nrow(tbl), function(i){combosCol[[i]][1, ] / combosCol[[i]][2, ]})
library(plyr)
cOdds <- ldply(cOdds)
colnames(cOdds) <- combosColnames
rownames(cOdds) <- rownames(tbl)
cOdds
oddsPairs <- lapply(1:ncol(cOdds), function(i) combn(cOdds[,i], m=2))
oddsPairs
oddsRatios <- lapply(1:ncol(cOdds), function(i) {oddsPairs[[i]][1,] / oddsPairs[[i]][2,]})
oddsRatios <- t(ldply(oddsRatios))
colnames(oddsRatios) <- combosColnames
rownames(oddsRatios) <- combosRownames
oddsRatios
tab <- table(honorsData$hon, honorsData$female)
tab
tab <- table(honorsData$hon, honorsData$female)
colnames(tab) <- c("Male", "Female")
rownames(tab) <- c("No", "Honors")
m.tab <- marginalTable(tab); m.tab
t(tab)
t(t(tab))
apply(tab, 2, rev)
apply(tab, 1, reverse)
apply(tab, 1, rev)
apply(apply(tab, 1, rev), 2, rev)
t1 <- apply(tab, 2, rev)
t1#
t2 <- apply(t1, 1, rev); t2#
t2 <- apply(t1, 1, rev)
t2 #
tab #
admitTable
apply(admitTable, 2, rev)
admitTable
apply(admitTable, 1, rev)
apply(t(admitTable), 1, rev)
apply(t(admitTable), 2, rev)
mt <- matrix(1:7, nrow=7, ncol=7)
mt #
mt <- matrix(1:7, nrow=7)
mt #
mt <- matrix(1:14, nrow=7)
mt #
apply(mt, 1, rev)
t(apply(mt, 1, rev))
t(apply(admitTable, 1, rev))
t(apply(tab, 1, rev))
ta #
tab#
mirrorHorizontal <- function(tbl){
t(apply(tbl, 1, rev))
}
mirrorVertical <- function(tbl){
apply(tbl, 2, rev)
}
mirror <- function(tbl){
mirrorVertical(mirrorHorizontal(tbl))
}
mirror(tab)
oddsRatio(mirror(tab))
oddsRatio(mirror(tab)) # same thing as just tab
oddsRatio(mirror(tab)) - 1
oddsRatio(mirror(admitTable))
oddsRatio(admitTable)
rowOdds(t(admitTable))
eyeTable <- as.table(matrix(c(20,30,10,15,10,25,15,12,20,10),byrow = TRUE, nrow=2))
rownames(eyeTable) <- c("Female", "Male")
colnames(eyeTable) <- c("Black", "Brown", "Blue", "Green", "Gray")
eyeTable
oddsRatio(eyeTable)
mirror(eyeTable)
mat <- matrix(1:28, nrow=7)
mat #
mirrorHorizontal(mat)
oddsRatio(mirror(eyeTable))
oddsRatio(eyeTable)
rep(5,3)
admitData <- data.frame(gender=c(rep("Male",6),rep("Female",6)),
dept=c("A","B","C","D","E", "F","A","B","C","D","E","F"),
admitted=c(512,353,120,138,53,22,89,17,202,131,94,24),
rejected=c(313,207,205,279,138,351,19,8,391,244,299,317))
admitData
admitData$total <- admitData$admitted + admitData$rejected
count <- cbind(admitData$admitted, admitData$rejected)
admit.glm <- glm(count ~ gender + dept, data=admitData, family=binomial)
summary(admit.glm)
options(digits=10, show.signif.stars = FALSE)
summary(admit.glm)
anova(admit.glm)
summary(admit.glm)
anova(admit.glm)
anova(admit.glm, test="Chisq")
877.05641-20.20428
ResidualDevianceTest(admit.glm)
summary(admit.glm)
anova(admit.glm, test="Chisq")
NullDevianceTest(admit.glm)
877.0564132-763.40273
DevianceTest(admit.glm)
DevianceTest(admit.glm)
877.05641 - 20.20428
anova(admit.glm, test="Chisq")
ResidualDevianceTest(admit.glm)
DevianceTest(admit.glm)
ResidualDevianceTest(admit.glm)
cof <- summary(admit.glm)$coef[,1:2]
cof
cof <- summary(admit.glm)$coef
cof
exp(cof)-1
exp(cof[,1:2])-1
