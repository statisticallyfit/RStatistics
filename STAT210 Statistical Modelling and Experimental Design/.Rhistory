}
count
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
warnings()
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count = count + 1
}
}
count
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferen.1
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
assertthat::count.1 == count.2
assertthat(count.1 == count.2)
assert_that(count.1 == count.2)
count.1 == count.2
probFaceValuesAllDifferent.2
1 - pbinom(100, size=105, n = 0.10)
1 - pbinom(100, size=105, prob = 0.10)
pbinom(100, size = 105, prob = 0.10, lower.tail=FALSE)
1 - pbinom(100, size=105, prob = 0.90)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
ppois(11, lambda=10, lower.tail = FALSE)
1 - ppois(11, lambda=10)
p = ppois(11, lambda=10, lower.tail = FALSE)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
1 - pbinom(2, size=8, prob=p)
p = pgeom(2, prob=0.8, lower.tail = FALSE)
p = pgeom(2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
1 - pgeom(2, prob=0.8)
p = pgeom(q=3, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
?pgeom
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
N <- 10^4
dice1 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice2 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice3 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
diceSum <- dice1 + dice2 + dice3
# part a) Probability that sum of face values < 10
probLessTen <- sum(diceSum < 10) / N; probLessTen
rolls <- cbind(dice1, dice2, dice3)
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
probFaceValuesAllDifferent.2
# Test to make sure: Should be true, the two methods yield the same answer.
count.1 == count.2
1 - pbinom(100, size=105, prob = 0.90)
# method 2 of calculating
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Assignment2_questions_1_4_5.R', echo=TRUE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
1 - ppois(11, lambda=10)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
# method 2
1 - ppois(11, lambda=10)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
# method 2
1 - pbinom(2, size=8, prob=p)
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
# Method 2
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
# Method 2
1 - pbinom(3, size=10, prob=p)
p = pgeom(q=0, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(2, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(0, prob=0.8) # P(X >= 2) = P(X <= 1)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/FORMULAS.R', echo=TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 9 - Logistic Regression/Lecture_Reading9_Genotype.R', echo=TRUE)
library(ggplot2)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 9 - Logistic Regression/Lecture_Reading9_Genotype.R', echo=TRUE)
DevianceTest(ratio.glm)
beetleData <- read.table("beetle.txt", header=TRUE)
beetleData <- setNames(beetleData, nm=c("Log10Dose", "Sample", "NumDead"))
beetleData # num dead is as response to exposure of various dosages of carbon disulphide.
# Plot of proportion killed against logdose
# the logistic curve.
ggplot(beetleData, aes(x=Log10Dose, y=NumDead/Sample)) +
geom_point(shape=19, size=3)
prop <- NumDead/Sample
beetle.glm <- glm(prop ~ Log10Dose, family="binomial", weights=Sample,
attach(beetleData)
prop <- NumDead/Sample
beetle.glm <- glm(prop ~ Log10Dose, family="binomial", weights=Sample,
beetleData <- read.table("beetle.txt", header=TRUE)
beetleData <- setNames(beetleData, nm=c("Log10Dose", "Sample", "NumDead"))
beetleData <- read.table("beetle.txt", header=TRUE)
beetleData <- setNames(beetleData, nm=c("Log10Dose", "Sample", "NumDead"))
beetleData # num dead is as response to exposure of various dosages of carbon disulphide.
ggplot(beetleData, aes(x=Log10Dose, y=NumDead/Sample)) +
geom_point(shape=19, size=3)
attach(beetleData)
prop <- NumDead/Sample
beetle.glm <- glm(prop ~ Log10Dose, family="binomial", weights=Sample,
data=beetleData)
summary(beetle.glm)
anova(beetle.glm, test="Chisq")
count <- cbind(NumDead, Sample - NumDead)
count
beetle2.glm <- glm(count ~ Log10Dose, family=binomial, data=beetleData)
beetle2.glm
beetle.glm # they are the same.
beetle.null.glm <- glm(count ~ 1, family=binomial,data=beetleData)
anova(beetle2.glm, test="Chisq")
ResidualDevianceTest(beetle2.glm) # the global fit for the model
DevianceTest(beetle2.glm) # the nested lik-ratio test with null model.
beetle2.glm$model[1]
beetle2.glm$model[[1]]
beetle.glm$model[1]
DevianceTest(beetle.glm)
count <- cbind(NumDead, Sample - NumDead)
count
beetle2.glm <- glm(count ~ Log10Dose, family=binomial, data=beetleData)
beetle2.glm
ResidualDevianceTest(beetle2.glm) # the global fit for the model
DevianceTest(beetle2.glm) # the nested lik-ratio test with null model.
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 9 - Logistic Regression/")
genderData <- read.table("gender.txt", header=TRUE)
is.factor(genderData$genotype)
attach(genderData)
plot(male/total ~ genotype)
ggplot(genderData, aes(x=genotype, y=male/total, group = genotype, color=genotype)) +
geom_boxplot(size=1)
p <- male/total
ratio.glm <- glm(p ~ genotype, family=binomial, weights=total, data=genderData)
count <- cbind(male, total-male)
ratio.glm <- glm(count ~ genotype, family=binomial, weights=total, data=genderData)
summary(ratio.glm)
anova(ratio.glm, test="Chisq")
ratio.glm <- glm(count ~ genotype, family=binomial, data=genderData)
summary(ratio.glm)
anova(ratio.glm, test="Chisq")
options(digits=10, show.signif.stars = FALSE)
anova(ratio.glm, test="Chisq")
DevianceTest(ratio.glm)
ratio.null.glm <- glm(count ~ 1, family=binomial, data=genderData)
anova(ratio.glm, test="Chisq")
DevianceTest(ratio.glm)
ResidualDevianceTest(ratio.glm)
anova(beetle2.glm, test="Chisq")
ResidualDevianceTest(beetle2.glm) # the global fit for the model
anova(ratio.glm, test="Chisq") # the p-value is for the deviance
# test method 2
ResidualDevianceTest(ratio.glm)
anova(beetle.null.glm, beetle2.glm, test="Chisq")
anova(beetle2.glm, test="Chisq")
ResidualDevianceTest(beetle2.glm) # the global fit for the model
anova(ratio.glm, test="Chisq") # the p-value is for the deviance
ResidualDevianceTest(ratio.glm)
anova(ratio.null.glm, ratio.glm)
DevianceTest(ratio.glm)
anova(ratio.null.glm, ratio.glm)
anova(ratio.null.glm, ratio.glm, test="Chisq")
DevianceTest(ratio.glm)
ResidualDevianceTest(ratio.glm)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/")
load("data/Exercises and Examples/ROADBIDS.Rdata")
options(digits=10, show.signif.stars = FALSE)
roads.glm <- glm(STATUS ~ NUMBIDS + DOTEST, family="binomial", data=ROADBIDS)
roads.null.glm <- glm(STATUS ~ 1, family="binomial", data=ROADBIDS)
ResidualDevianceTest(roads.glm)
ResidualDevianceTest(roads.glm) # individual global fit
DevianceTest(roads.glm) # nested between null and roads
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/FORMULAS.R', echo=TRUE)
ResidualDevianceTest(beetle2.glm) # the global fit for the model
ResidualDevianceTest(ratio.glm)
anova(ratio.null.glm, ratio.glm, test="Chisq")
DevianceTest(ratio.glm)
summary(ratio.glm)
cof <- coef(ratio.glm)
cof
cof <- summary(ratio.glm)
cof
cof[,1:2]
cof[1,1]
class(cof)
cof <- ratio.glm$coefficients
cof
cof <- summary(ratio.glm)
cof$coefficients
cof <- summary(ratio.glm)$coef
class(cof)
cof[,1:2]
1 - pchisq((cof[,1] / cof[,2])^2, df=1)
genderData.C <- genderData
genderData.C$genotype <- relevel(genderData$genotype, ref="C")
ratio.C.glm <- glm(count <- genotype, family=binomial, data=genderData.C)
count
genderData.C
levels(genderData.C)
detach(genderData)
detach(genderData)
detach(genderData)
detach(genderData)
genderData.C <- genderData
count.C <- cbind(genderData.C$male, genderData.C$total - genderData.C$male)
count.C
cbind(count, count.C)
count #
count <- cbind(genderData$male, genderData$total - genderData$male)
count
cbind(count, count.C)
ratio.C.glm <- glm(count.C <- genotype, family=binomial, data=genderData.C)
genderData.C
levels(genderData)
genderData
levels(genderData$genotype)
levels(genderData.C$genotype)
genderData.C$genotype <- relevel(genderData$genotype, ref="C")
levels(genderData.C$genotype)
count.C <- cbind(genderData.C$male, genderData.C$total - genderData.C$male)
cbind(count, count.C)
ratio.C.glm <- glm(count.C <- genotype, family=binomial, data=genderData.C)
ratio.C.glm <- glm(count ~ genotype, family=binomial, data=genderData.C)
count <- cbind(genderData$male, genderData$total - genderData$male)
ratio.C.glm <- glm(count ~ genotype, family=binomial, data=genderData.C)
ratio.C.glm
summary(ratio.C.glm)
anova(ratio.C.glm)
ResidualDevianceTest(ratio.glm)
nrow(genderData)
ratio.glm
summary(ratio.glm)
nrow(genderData)
ratio.glm$null.deviance
ratio.glm$df.null
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 9 - Logistic Regression/")
honorsData <- read.table("honors.txt", header=TRUE)
honor.0.glm <- glm(hon ~ 1, family=binomial, data=honorsData)
summary(honor.0.glm)
frequency(honorsData$hon)
table(honorsData$hon)
table(honorsData$hon)/nrow(honorsData)
rbind(table(honorsData$hon), table(honorsData$hon)/nrow(honorsData))
freq <- rbind(table(honorsData$hon), table(honorsData$hon)/nrow(honorsData))
freq <- data.frame(freq)
freq
View(honorsData)
colnames(freq) <- c("No", "Honors")
rownames(freq) <- c("Freq", "Percent")
freq
t(freq)
freq <- rbind(table(honorsData$hon),
100*table(honorsData$hon)/nrow(honorsData))
freq <- data.frame(freq)
colnames(freq) <- c("No", "Honors")
rownames(freq) <- c("Freq", "Percent")
freq <- t(freq)
freq
honor.0.glm$family$linkinv(-1.12546)
intercept <- summary(honor.0.glm)$coefficients[1,1]
intercept
honor.0.glm$family$linkinv(intercept)
honor.0.glm$family$link(0.245)
honor.0.glm$family$linkfun(0.245)
honor.0.glm$family$linkfun(0.245) == intercept
honor.female.glm <- glm(hon ~ female, data=honorsData, family="binomial")
summary(honor.female.glm)
table(honorsData$hon, honorsData$female)
rowProbabilityHat <- function(tbl){prop.table(tbl, margin=1)}
colProbabilityHat <- function(tbl){prop.table(tbl, margin=2)}
# ---------------------- Returns table with marginal row/col sums ------------------------------
################ TODO make for k-way tables too, not just two-way
marginalTable <- function(tbl) {
extraRow <- cbind(tbl, RowTotals=margin.table(tbl, margin=1))
extraCol <- rbind(extraRow, ColTotals=margin.table(extraRow, margin=2))
dms <- dimnames(tbl)
dms[[1]] <- c(dms[[1]], "ColTotals")
dms[[2]] <- c(dms[[2]], "RowTotals")
dimnames(extraCol) <- dms
return(extraCol)
}
attach(honorsData)
rowProbabilityHat(table(hon, female))
tab <- table(hon, female)
marginalTable(tab)
tab <- table(hon, female)
rowProbabilityHat(tab)
marginalTable(tab)
oddsRatio <- function(tbl) {
### make names combos
combosColnames <- combn(colnames(tbl), m=2)
combosColnames <- paste(combosColnames[1,], "/", combosColnames[2,], sep="")
combosRownames <- combn(rownames(tbl), m=2)
combosRownames <- paste(combosRownames[1, ], "/", combosRownames[2,], sep="")
### make odds for each col, holding rows constant
combosCol <- lapply(1:nrow(tbl), function(i) combn(tbl[i,], m=2))
oddsCol <- lapply(1:nrow(tbl), function(i){combosCol[[i]][1, ] / combosCol[[i]][2, ]})
library(plyr)
oddsCol <- ldply(oddsCol)
colnames(oddsCol) <- combosColnames
rownames(oddsCol) <- rownames(tbl)
oddsPairs <- lapply(1:ncol(oddsCol), function(i) combn(oddsCol[,i], m=2))
oddsRatios <- lapply(1:ncol(oddsCol), function(i) {oddsPairs[[i]][1,] / oddsPairs[[i]][2,]})
oddsRatios <- t(ldply(oddsRatios))
colnames(oddsRatios) <- combosColnames
rownames(oddsRatios) <- combosRownames
return(oddsRatios)
}
oddsRatio(tab)
library(DescTools)
OddsRatio(tab)
OddsRatio(hon, female)
OddsRatio(hon, female)
OddsRatio(hon, male)
OddsRatio(hon, female)
oddsRatio(tab) - 1
OddsRatio(hon, female) - 1
od <- oddsRatio(tab)
class(od)
od[1,1] - 1
tab
tabl <- marginalTable(tab) # female (1), male(0)
tab <- marginalTable(tab) # female (1), male(0)
tab
oddsMales <- tab[1,1]/tab[2,1]
oddsMales <- tab[1,1]/tab[2,1]; oddsMales
oddsMales <- tab[2,1]/tab[1,1]; oddsMales
oddsFem <- tab[2,2] / tab[1,2]; oddsFem
oddsFem/oddsMales
ln(oddsMales)
log(oddsMales)
cof <- summary(honor.female.glm)$coef
cof[1,1]
log(oddsFem/oddsMales)
cof[2,1]
cof
e^cof
exp(cof)
honor.math.glm <- glm(hon ~ math, data=honorsData, family=binomial)
summary(honor.math.glm)
cof <- summary(honor.math.glm)$coef
cof
exp(cof)
ResidualDevianceTest(honor.math.glm)
ResidualDevianceTest(beetle2.glm)
anova(beetle2.glm, test="Chisq")
Deviance(beetle2.glm)
DevianceTest(beetle2.glm)
DevianceTest(beetle2.glm) # the nested lik-ratio test with null model.
DevianceTest(beetle2.glm) # the nested lik-ratio test with null model.
ResidualDevianceTest(beetle2.glm) # the global fit for the model
DevianceTest(beetle2.glm) # the nested lik-ratio test with null model.
ResidualDevianceTest(beetle2.glm) # the global fit for the model
preds <- predict.glm(beetle2.glm, se.fit=T, type="response") #scale proportions
preds
pred.df <- data.frame(fit.back=preds$fit,
lwr.back= preds$fit - 1.96*preds$se.fit,
upr.back = preds$fit + 1.96 * preds$se.fit)
head(pred.df)
ggplot(data=beetleData, aes(x=Log10Dose, y=NumDead/Sample)) + geom_point(shape=19, size=3) +
geom_line(data=pred.df, aes(y=fit.back), col="red") +
geom_line(data=pred.df, aes(y=lwr.back), col="red") +
geom_line(data=pred.df, aes(y=upr.back), col="red") +
geom_line(data=pred.df, aes(y=upr.back), col="red")
newd <- data.frame(Log10Dose=seq(min(Log10Dose), max(Log10Dose), by = 0.01))
preds <- predict.glm(beetle2.glm, newdata=newd, se.fit=T, type="response") #scale proportions
pred.df <- data.frame(fit.back=preds$fit,
lwr.back= preds$fit - 1.96*preds$se.fit,
upr.back = preds$fit + 1.96 * preds$se.fit)
head(pred.df); nrow(pred.df)
head(pred.df); nrow(pred.df); nrow(beetleData)
newd <- data.frame(Log10Dose=seq(min(Log10Dose), max(Log10Dose), by = 0.009))
preds <- predict.glm(beetle2.glm, newdata=newd, se.fit=T, type="response") #scale proportions
pred.df <- data.frame(fit.back=preds$fit,
lwr.back= preds$fit - 1.96*preds$se.fit,
upr.back = preds$fit + 1.96 * preds$se.fit)
head(pred.df); nrow(pred.df); nrow(beetleData)
ggplot(data=beetleData, aes(x=Log10Dose, y=NumDead/Sample)) + geom_point(shape=19, size=3) +
geom_line(data=pred.df, aes(y=fit.back), col="blue") +
geom_line(data=pred.df, aes(y=lwr.back), col="red") +
geom_line(data=pred.df, aes(y=upr.back), col="red")
pred.df <- data.frame(fit.back=preds$fit,
lwr.back= preds$fit - 1.96*preds$se.fit,
upr.back = preds$fit + 1.96 * preds$se.fit,
Log10Dose=newd)
head(pred.df); nrow(pred.df); nrow(beetleData)
ggplot(data=beetleData, aes(x=Log10Dose, y=NumDead/Sample)) + geom_point(shape=19, size=3) +
geom_line(data=pred.df, aes(y=fit.back), col="blue") +
geom_line(data=pred.df, aes(y=lwr.back), col="red") +
geom_line(data=pred.df, aes(y=upr.back), col="red")
newd <- data.frame(Log10Dose=seq(min(Log10Dose), max(Log10Dose), by = 0.001))
preds <- predict.glm(beetle2.glm, newdata=newd, se.fit=T, type="response") #scale proportions
pred.df <- data.frame(fit.back=preds$fit,
lwr.back= preds$fit - 1.96*preds$se.fit,
upr.back = preds$fit + 1.96 * preds$se.fit,
Log10Dose=newd)
head(pred.df); nrow(pred.df); nrow(beetleData)
ggplot(data=beetleData, aes(x=Log10Dose, y=NumDead/Sample)) + geom_point(shape=19, size=3) +
geom_line(data=pred.df, aes(y=fit.back), col="blue") +
geom_line(data=pred.df, aes(y=lwr.back), col="red") +
geom_line(data=pred.df, aes(y=upr.back), col="red")
ggplot(data=beetleData, aes(x=Log10Dose, y=NumDead/Sample)) + geom_point(shape=19, size=3) +
geom_line(data=pred.df, aes(y=fit.back), col="blue", size=1) +
geom_line(data=pred.df, aes(y=lwr.back), col="red", size=1, linetype="dashed") +
geom_line(data=pred.df, aes(y=upr.back), col="red", size=1, linetype="dashed")
exp(1.77)
beetle2.glm
(log(3) + 60.71745)/34.27033
predict(beetle2.glm, type="response", newdata=data.frame(Log10Dose=1.69))
p = predict(beetle2.glm, type="response", newdata=data.frame(Log10Dose=1.69))
beetleData
expected = p * 59; expected
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/")
load("data/Exercises and Examples/ROADBIDS.Rdata")
options(digits=10, show.signif.stars = FALSE)
# status = 1 (fixed bid), status = 0 (competitive bid)
roads.glm <- glm(STATUS ~ NUMBIDS + DOTEST, family="binomial", data=ROADBIDS)
summary(roads.glm)
anova(roads.glm, test="Chisq")
anova(roads.glm, test="Chisq")
ResidualDevianceTest(roads.glm) # individual global fit
anova(roads.glm, test="Chisq")
ResidualDevianceTest(roads.glm) # individual global fit
ResidualDevianceTest(roads.glm)
DevianceTest(roads.glm) # nested between null and roads
ResidualDevianceTest(roads.glm) # global fit of numbids + dotest model
anova(roads.glm, test="Chisq")
DevianceTest(roads.glm) # nested between null and roads
LikelihoodRatioNestedTest(glm(STATUS ~ NUMBIDS, data=ROADBIDS, family=binomial),
roads.glm)
roads.numbids.glm <- glm(STATUS ~ NUMBIDS, data=ROADBIDS, family=binomial)
DevianceTest(roads.numbids.glm)
anova(roads.glm, test="Chisq")
LikelihoodRatioNestedTest(roads.numbids.glm,roads.glm)
DevianceTest(roads.numbids.glm)
DevianceTest(roads.glm) # nested between null and roads
LikelihoodRatioNestedTest(roads.numbids.glm,roads.glm)
LikelihoodRatioNestedTest(roads.numbids.glm,roads.glm)
DevianceTest(roads.glm) # nested between null and roads
ResidualDevianceTest(roads.glm) # global fit of numbids + dotest model
anova(roads.glm)
ResidualDevianceTest(roads.glm) # global fit of numbids + dotest model
anova(roads.glm)
anova(roads.glm, test="Chisq")
DevianceTest(roads.numbids.glm)
LikelihoodRatioNestedTest(roads.numbids.glm,roads.glm)
anova(roads.glm, test="Chisq")
ResidualDevianceTest(roads.glm) # global fit of numbids + dotest model
anova(roads.glm, test="Chisq")
ResidualDevianceTest(roads.glm) # global fit of numbids + dotest model
ResidualDevianceTest(roads.numbids.glm)
ResidualDevianceTest(roads.glm) # global fit of numbids + dotest model
DevianceTest(roads.glm) # nested between null and roads
LikelihoodRatioNestedTest(roads.numbids.glm,roads.glm) # signif diff between them
DevianceTest(roads.numbids.glm) #  significant diff between them
predict(roads.glm, type="response", newdata=data.frame(NUMBIDS=5, DOTEST=-10))
cof
cof <- summary(roads.glm)$coef
exp(cof)
exp(cof[,1]) -1
ResidualDevianceTest(roads.numbids.glm) # good model numbids since resid dev is small
