cat("Df:                                                   ", test$par, "\n")
cat("P-value:                                              ", test$p.value, "\n\n")
return(invisible(result))
}
return(result)
}
HosmerLemeshowTest_Calc <- function(model, g=10, printNice=TRUE){
pi.hat <- model$fitted.values
# categorize observations into deciles of the predicted probabilities
#pi.hat.grouped <- cut(pi.hat,
#                      breaks=c(0,quantile(pi.hat, probs=seq(0.1, 0.9,0.1)), 1),
#                      labels=FALSE)
pi.hat.grouped <- cut(pi.hat, breaks = quantile(pi.hat,
probs = seq(0, 1, 1/g)),
include.lowest = T)
# cycle through 1:10 groups, counting the observed
# number of 0s and 1s, and the expected number of 0s and 1s.
# To find expected 0s and 1s, find mean of predicted
# probabilities in each group and multiply by group size (10)
meanProbs <- array(0, dim=c(10,2))
exp.0.1 <- array(0, dim=c(10,2))
obs.0.1 <- array(0, dim=c(10,2))
for(i in 1:10){
# for 1's
meanProbs[i,1] <- mean(pi.hat[pi.hat.grouped == i]) # purpose for exp.0.1 only
exp.0.1[i,1] <- sum(pi.hat.grouped == i) * meanProbs[i,1]
obs.0.1[i,1] <- sum(y[pi.hat.grouped == i])
# for 0's
meanProbs[i,2] <- mean(1 - pi.hat[pi.hat.grouped == i]) # purpose for exp.0.1 only
exp.0.1[i,2] <- sum(pi.hat.grouped == i) * meanProbs[i,2]
obs.0.1[i,2] <- sum(1 - y[pi.hat.grouped == i])
}
# now statistic is found by sum of observed-expected over 10x2 cells of the table.
library(ResourceSelection)
stat <- sum((obs.0.1 - exp.0.1)^2 / exp.0.1)
result <- data.frame(HLStat=stat, Df=g-2, PValue=1-pchisq(stat, g-2),
Expected=hoslem.test(model$y, model$fitted.values, g=g)$exp)
if(printNice){
cat("################################################################\n")
cat("##########            Hosmer-Lemeshow Test            ##########\n")
cat("################################################################\n")
cat("\tHo: current model fits well: "); print(model$formula);
cat("\tHa: current model does NOT fit well\n\n")
cat("HL statistic:                                         ", result$HL, "\n")
cat("Df:                                                   ", result$Df, "\n")
cat("P-value:                                              ", result$P, "\n\n")
return(invisible(result))
}
return(result)
}
HosmerLemeshowTest_T <- function (y, y.hat=n*prob, g = 10) {
cut_y.hat <- cut(y.hat,
breaks = quantile(y.hat, probs = seq(0, 1, 1/g)),
include.lowest = T)
obs <- xtabs(cbind(1 - y, y) ~ cut_y.hat)
expect <- xtabs(cbind(1 - y.hat, y.hat) ~ cut_y.hat)
chisq <- sum((obs - expect)^2/expect)
result <- data.frame(X2 = chisq, Df = g - 2, PValue = 1-pchisq(chisq, g-2))
row.names(result) <- ""
return(result)
}
SSE <- function(y, yhat) {
return(sum( (y - yhat)^2 ))
}
standardErrorOfRegression <- function(y, yhat) {
sse.value <- invisible(SSE(y, yhat))
n <- length(y)
return (sqrt((sse.value) / (n - 2)))
}
standardErrorOfRegression <- function(sse.value, n) {
return(sqrt(sse.value / (n - 2)))
}
# OR
#a <- anova(lm)
#ss <- a$`Sum Sq`
#return(ss[length(ss)])
# OR
#s <- summary(r.lm)
#(1-s$r.squared)*SST(var$datamat$dc)
SST <- function(y) {
return(sum( (y - mean(y))^2 ))
}
standardErrorOfRegression(yi, yhat)
standardErrorOfRegression <- function(y, yhat) {
sse.value <- invisible(SSE(y, yhat))
n <- length(y)
return (sqrt((sse.value) / (n - 2)))
}
standardErrorOfRegression(yi, yhat)
load("data/Exercises and Examples/FHWABRIDGE.Rdata")
reg.line <- lm(AREA ~ NUMBER, data = FHWABRIDGE)
reg.line
summary(reg.line)
# degrees freedom = n - 2 = 52 - 2 = 50
n <- nrow(FHWABRIDGE); n
# from FORMULAS (source the file)
yi <- FHWABRIDGE$AREA
yhat <- reg.line$fitted.values
SSE(yi, yhat)
standardErrorOfRegression(yi, yhat)
standardErrorOfRegression <- function(sse.value, n) {
return(sqrt(sse.value / (n - 2)))
}
standardErrorOfRegression(yi, yhat)
standardErrorOfRegression <- function(y, yhat) {
sse.value <- invisible(SSE(y, yhat))
n <- length(y)
return (sqrt((sse.value) / (n - 2)))
}
summary(reg.line)
load("data/Exercises and Examples/OJUICE.Rdata")
View(OJUICE)
reg.line <- lm(PECTIN ~ SWEET)
summary(reg.line)
reg.line <- lm(PECTIN ~ SWEET, data=OJUICE)
summary(reg.line)
reg.line <- lm(SWEET ~ PECTIN, data=OJUICE)
summary(reg.line)
anova(reg.line)
SSyy <- function(y, y.mean) {
n <- length(y)
return (sum(y - y.mean))^2
}
reg.line <- lm(SWEET ~ PECTIN, data=OJUICE)
summary(reg.line)
anova(reg.line)
y <- OJUICE$SWEET
yhat <- reg.line$fitted.values
SSyy(y, mean(y))
y
SSyy <- function(y, y.mean) {
n <- length(y)
return ((sum(y - y.mean))^2 )
}
SSxx <- function(x, x.mean) {
n <- length(x)
return ((sum(x - x.mean))^2)
}
SSyy(y, mean(y))
y <- OJUICE$SWEET
yhat <- reg.line$fitted.values
y - mean(y)
y
mean(y)
5.2-mean(y)
5.5-mean(y)
x <- OJUICE$PECTIN
SSxx(x, mean(x))
SSxy <- function(x, y) {
x.mean <- mean(x)
y.mean <- mean(y)
return ( ((sum(x - x.mean))^2) * ((sum(y - y.mean))^2) )
}
SSxy(x, y)
reg.line$coefficients[1]
reg.line$coefficients[2]
SSyy(y, mean(y)) - reg.line$coefficients[2] * SSxy(x,y)
reg.line$coefficients[2]
reg.line$coefficients[[2]]
SSyy(y, mean(y)) - reg.line$coefficients[[2]] * SSxy(x,y)
SSE(y, yhat)
SSyy <- function(y) {
y.mean <- mean(y)
return ((sum(y - y.mean))^2 )
}
SSxx <- function(x) {
x.mean <- mean(x)
return ((sum(x - x.mean))^2)
}
SSyy(y)
SSxx(x)
a <- c(10,11,12,1,3,-4,5,13)
b <- c(3,4,-23,1,2,39,1,32)
(a - b)
(a - b)^2
sum((a - b)^2)
SSE <- function(y, yhat) {
return(sum( (y - yhat)^2 ))
}
standardErrorOfRegression <- function(y, yhat) {
sse.value <- invisible(SSE(y, yhat))
n <- length(y)
return (sqrt((sse.value) / (n - 2)))
}
SSyy <- function(y) {
y.mean <- mean(y)
return ( sum( (y - y.mean)^2 ) )
}
SSxx <- function(x) {
x.mean <- mean(x)
return ( sum( (x - x.mean)^2 ) )
}
SSxy <- function(x, y) {
x.mean <- mean(x)
y.mean <- mean(y)
return ( ( sum( (x - x.mean)^2 ) ) * ( sum( (y - y.mean)^2 ) ) )
}
#standardErrorOfRegression <- function(sse.value, n) {
#      return(sqrt(sse.value / (n - 2)))
#}
# OR
#a <- anova(lm)
#ss <- a$`Sum Sq`
#return(ss[length(ss)])
# OR
#s <- summary(r.lm)
#(1-s$r.squared)*SST(var$datamat$dc)
SST <- function(y) {
return ( sum( (y - y.mean)^2 ) )
}
SSE(y, yhat)
summary(reg.line)
anova(reg.line)
y <- OJUICE$SWEET
yhat <- reg.line$fitted.values
x <- OJUICE$PECTIN
SSE(y, yhat)
SSxx(x)
SSyy(y)
SSxy(x, y)
SSyy(y, mean(y)) - reg.line$coefficients[[2]] * SSxy(x,y)
SSyy(y) - reg.line$coefficients[[2]] * SSxy(x,y)
SSE(y, yhat)
reg.line <- lm(SWEET ~ PECTIN, data=OJUICE)
summary(reg.line)
reg.line$coefficients[[2]]
n <- length(y)
sum(y^2) - n*(mean(y))^2
SSyy(y)
sum(x * y) - n(mean(x)*mean(y))
sum(x * y) - n*(mean(x)*mean(y))
SSxy(x, y)
x*y
sum(x*y)
(x - x.mean)^2 * (y - y.mean)^2
x.mean <- mean(x)
y.mean <- mean(y)
(x - x.mean)^2 * (y - y.mean)^2
((x - x.mean)^2) * ((y - y.mean)^2)
SSxy <- function(x, y) {
x.mean <- mean(x)
y.mean <- mean(y)
return ( sum( (x - x.mean)^2 * (y - y.mean)^2 ) )
}
SSyy(y) - reg.line$coefficients[[2]] * SSxy(x,y)
SSxy(x, y)
sum(x * y) - n*(mean(x)*mean(y))
SSxy(x, y)
SSE(y, yhat)
SSyy(y) - reg.line$coefficients[[2]] * SSxy(x,y)
SSxy <- function(x, y) {
x.mean <- mean(x)
y.mean <- mean(y)
return ( sum( ((x - x.mean)^2) * ((y - y.mean)^2) ) )
}
SSxy(x, y)
sum(x * y) - n*(mean(x)*mean(y))
SSxy <- function(x, y) {
x.mean <- mean(x)
y.mean <- mean(y)
return ( sum( (x - x.mean) * (y - y.mean) ) )
}
SSxy(x, y)
sum(x * y) - n*(mean(x)*mean(y))
SSyy(y) - reg.line$coefficients[[2]] * SSxy(x,y)
SSyy(y)
SSxx(x)
SSE(y, yhat)
slope <- reg.line$coefficients[[2]]
sse <- SSyy(y) - slope * SSxy(x,y)
sse <- SSyy(y) - slope * SSxy(x,y); sse
s <- standardErrorOfRegression(y, yhat); s
SSE(y,yhat) / (n - 2)
n
sqrt(SSE(y,yhat) / (n - 2))
standardErrorOfSlope <- function(x, y, yhat) {
s <- standardErrorOfRegression(y, yhat)
return (s / sqrt(SSxx(x)))
}
standardErrorOfSlope(x, y, yhat)
summary(reg.line)
standardErrorOfSlope(x, y, yhat)
s/sqrt(SSxy(x,y))
s/(sqrt(SSxy(x,y)))
SSxx(x)
anova(reg.line)
qt(0.05, 22)
abs(-3)
slopeCI <- function(x, y, level = 0.95) {
model <- lm(y ~ x)
slope <- model$coefficients[[2]]
sB1 <- standardErrorOfSlope(x, y, model$fitted)
# Calculate alpha for the t-statistic, and df
alpha <- 1 - level
n <- length(y)
df <- n - 2
t.alpha2 <- abs(qt(alpha/2, df))
# calculate conf.int
leftCI <- slope - t.alpha2 * sB1
rightCI <- slope + t.alpha2 * sB1
return( c(leftCI, rightCI) )
}
slopeCI(x, y, level=0.90)
reg.line$df.residual
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation")
interpret.SlopeCI <- function(x, y, level=0.95, x.unit="unit", x.name="x",
y.unit="unit", y.name="y" )  {
tuple <- slopeCI(x, y, level)
leftCI <- tuple[1]
rightCI <- tuple[2]
return ("There is a " + level*100 + "% chance that for each 1 " + x.unit +
" increase in " + x.name + ", the predicted response " + y.name +
" is expected to increase between " + leftCI + " " + x.unit +
" and " + rightCI + " " + y.unit + ".")
}
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation")
cat("hello ", 3, " there")
cat("hello", 3, "there")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation")
100 * -0.003864436
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
integer(1.0)
int(1.0)
class(1)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", amount.x.unit.increase=1, y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", amount.x.unit.increase=1, y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", TRUE, TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", x.unit.IsPercent=TRUE, y.unit.IsPercent=TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", x.unit.IsPercent=TRUE, y.unit.IsPercent=TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", x.unit.IsPercent=TRUE, y.unit.IsPercent=TRUE)
interpret.SlopeCI(x, y, level=0.9, x.unit="% per degree", x.name="active head movement", y.unit="% per degree", y.name="body and head rotation", x.unit.IsPercent=TRUE, y.unit.IsPercent=TRUE)
load("data/Exercises and Examples/NAMEGAME2.Rdata")
View(NAMEGAME2)
reg.line <- lm(RECALL ~ POSITION, data=NAMEGAME2)
summary(reg.line)
load("data/Exercises and Examples/BRAINPAIN.Rdata")
View(BRAINPAIN)
reg.line <- lm(ACTIVITY ~ EMPATHY, data=BRAINPAIN)
summary(reg.line)
reg.line$model
reg.line <- lm(RECALL ~ POSITION, data=NAMEGAME2)
summary(reg.line)
summary(reg.line)
load("data/Exercises and Examples/LIQUIDSPILL.Rdata")
View(LIQUIDSPILL)
reg.line <- lm(MASS ~ TIME, data=LIQUIDSPILL)
summary(reg.line)
nrow(LIQUIDSPILL)
y <- LIQUIDSPILL$MASS
x <- LIQUIDSPILL$TIME
yhat <- reg.line$fitted.values
s <- standardErrorOfRegression(y, yhat)
s <- standardErrorOfRegression(y, yhat); s
summary(reg.line)
mean(x)
SSxx(x)
?MeanCI
meanCI <- function(x, y, model, x.value, level=0.95) {
# finding the yhat value at a particular x-.value
yhat.at.xp <- model$coeff[[2]] * x.value + model$coeff[[1]]
# Finding the std error of regression, s
s <- standardErrorOfRegression(y, yhat)
# Finding the t, alpha
alpha <- 1 - level
n <- length(y)
df <- n - 2
t.alpha2 <- abs(qt(alpha/2, df))
# Calculating the confidence interval.
leftCI <- yhat.at.xp - t.alpha2 * s * sqrt(1/n + (x.value - mean(x))^2 / SSxx(x))
rightCI <- yhat.at.xp + t.alpha2 * s * sqrt(1/n + (x.value - mean(x))^2 / SSxx(x))
return(c(leftCI, rightCI))
}
meanCI(x, y, reg.line, x.value=15, level=0.90)
interpret.MeanCI <- function(x, y, model, x.value, level=0.95,
x.unit="unit", x.name="x",
y.unit="unit", y.name="y",
x.unit.IsPercent=FALSE,
y.unit.IsPercent=FALSE){
tuple <- meanCI(x,y, model, x.value, level)
leftCI <- tuple[1]
rightCI <- tuple[2]
leftCIValue <- 0
rightCIValue <- 0
if(y.unit.IsPercent){
leftCIValue <- leftCI * 100
rightCIValue <- rightCI * 100
}
#print(amount.x.unit.increase)
return(
cat("There is a ", level*100, " % chance that the interval (", leftCI, ", ", rightCI,
") encloses the mean y (", y.name, " in ", y.unit, ") for all xs (",
x.name, " in ", x.unit, ") when x = ", x.value, sep=""))
}
interpret.MeanCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.MeanCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.MeanCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
predictCI <- function(x, y, model, x.value, level=0.95) {
# finding the yhat value at a particular x-.value
yhat.at.xp <- model$coeff[[2]] * x.value + model$coeff[[1]]
# Finding the std error of regression, s
s <- standardErrorOfRegression(y, yhat)
# Finding the t, alpha
alpha <- 1 - level
n <- length(y)
df <- n - 2
t.alpha2 <- abs(qt(alpha/2, df))
# Calculating the confidence interval.
leftCI <- yhat.at.xp - t.alpha2 * s * sqrt(1 + 1/n + (x.value - mean(x))^2 / SSxx(x))
rightCI <- yhat.at.xp + t.alpha2 * s * sqrt(1 + 1/n + (x.value - mean(x))^2 / SSxx(x))
return(c(leftCI, rightCI))
}
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.PredictCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.PredictCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.PredictCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.PredictCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.PredictCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.PredictCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
interpret.MeanCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.MeanCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
interpret.PredictCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds", x.name="mass", y.unit="minutes",y.name="time")
meanCI(x, y, reg.line, x.value=15, level=0.90)
interpret.MeanCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds",
x.name="mass", y.unit="minutes",y.name="time")
predictCI(x, y, reg.line, x.value=15, level=0.90)
interpret.PredictCI(x, y, reg.line, x.value=15, level=0.90, x.unit="pounds",
x.name="mass", y.unit="minutes",y.name="time")
load("data/Exercises and Examples/WHITESPRUCE.Rdata")
View(WHITESPRUCE)
reg.line <- lm(HEIGHT ~ DIAMENTER, data=WHITESPRUCE)
reg.line <- lm(HEIGHT ~ DIAMETER, data=WHITESPRUCE)
summary(reg.line)
x <- WHITESPRUCE$DIAMETER
yhat <- reg.line$fitted.values
y <- WHITESPRUCE$HEIGHT
x <- WHITESPRUCE$DIAMETER
yhat <- reg.line$fitted.values
meanCI(x, y, reg.line, x.value=20, level=0.90)
interpret.MeanCI(x, y, reg.line, x.value=20, level=0.90, x.unit="cm",
x.name="breast height diameter", y.unit="height",y.name="meters")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.MeanCI(x, y, reg.line, x.value=20, level=0.90, x.unit="cm",
x.name="breast height diameter", y.unit="height",y.name="meters")
interpret.MeanCI(x, y, reg.line, x.value=20, level=0.90, x.unit="cm",
x.name="breast height diameter", y.unit="m",y.name="height")
predictCI(x, y, reg.line, x.value=20, level=0.90)
interpret.PredictCI(x, y, reg.line, x.value=20, level=0.90, x.unit="cm",
x.name="breast height diameter", y.unit="height",y.name="meters")
interpret.PredictCI(x, y, reg.line, x.value=20, level=0.90, x.unit="cm",
x.name="breast height diameter", y.unit="m",y.name="height")
y <- FHWABRIDGE$AREA
yhat <- reg.line$fitted.values
x <- FHWABRIDGE$NUMBER
reg.line <- lm(AREA ~ NUMBER, data = FHWABRIDGE)
reg.line
summary(reg.line)
meanCI(x, y, reg.line, x.value=350)
y <- FHWABRIDGE$AREA
yhat <- reg.line$fitted.values
x <- FHWABRIDGE$NUMBER
reg.line <- lm(AREA ~ NUMBER, data = FHWABRIDGE)
reg.line
meanCI(x, y, reg.line, x.value=350)
interpret.MeanCI(x, y, reg.line, x.value=350, level=0.90, x.unit="bridges",
x.name="number of bridges", y.unit="thousands of sq. ft",y.name="area")
interpret.MeanCI(x, y, reg.line, x.value=350, x.unit="bridges",
x.name="number of bridges", y.unit="thousands of sq. ft",y.name="area")
meanCI(x, y, reg.line, x.value=350)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.MeanCI(x, y, reg.line, x.value=350, x.unit="bridges",
x.name="number of bridges", y.unit="thousands of sq. ft",y.name="area")
predictCI(x, y, reg.line, x.value=350)
interpret.PredictCI(x, y, reg.line, x.value=350, x.unit="bridges",
x.name="number of bridges", y.unit="thousands of sq. ft",y.name="area")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/INTERPRET.R', echo=TRUE)
interpret.MeanCI(x, y, reg.line, x.value=350, x.unit="bridges",
x.name="number of bridges", y.unit="thousands of sq. ft",y.name="area")
interpret.PredictCI(x, y, reg.line, x.value=350, x.unit="bridges",
x.name="number of bridges", y.unit="thousands of sq. ft",y.name="area")
