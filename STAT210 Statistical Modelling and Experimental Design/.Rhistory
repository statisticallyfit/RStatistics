for (p in patterns) {
# If no detecting of a pattern, then is INDEP ARG
if (!str_detect(n, p)){
args <- c(args, n)
}
}
}
return(args)
}
findSimpleArgs(gas.lm)
str_detect(allNames, "\\:")
!str_detect(allNames, "\\:")
str_detect(allNames, "\\^")
testExtra <- str_detect(allNames, "\\^")
testExtra == TRUE
allNames(testExtra)
allNames[testExtra]
findSimpleArgs <- function(fit){
allNames <- names(fit$coefficients)[-1]
patterns <- c("\\^", "\\:")
args <- c()
extraArgs <- c()
for (p in patterns) {
# If no detecting of a pattern, then is INDEP ARG
testExtra <- str_detect(allNames, p)
extraArgs <- c(extraArgs, allNames[testExtra])
}
return(args)
}
findSimpleArgs(fit)
findSimpleArgs(gas.lm)
gas.lm
fit #
allNames <- names(fit$coefficients)[-1]
patterns <- c("\\^", "\\:")
allNames <- names(fit$coefficients)[-1]
patterns <- c("\\^", "\\:")
args <- c()
extraArgs <- c()
for (p in patterns) {
# If no detecting of a pattern, then is INDEP ARG
testExtra <- str_detect(allNames, p)
extraArgs <- c(extraArgs, allNames[testExtra])
}
extraArgs
extraArgs %in% allNames
!extraArgs %in% allNames
extraArgs[!extraArgs %in% allNames]
allNames
extraArgs
allNames == extraArgs
which(!extraArgs %in% allNames)
str_subset(allNames, extraArgs)
str_subset(allNames, extraArgs[1])
xs <- 1:10
ys <- 1:5
xs #
ys #
ys %in% xs #
A <- c("A", "B", "C", "D")
B <- c("A", "B", "C")
(new <- A[which(!A %in% B)])
which(!xs %in% ys)
xs = 12:20
ys = 12:14
which(!xs %in% ys)
indicesNotExtraArgs <- which(!allNames %in% extraArgs)
indicesNotExtraArgs
args <- allNames(indicesNotExtraArgs)
findSimpleArgs <- function(fit){
allNames <- names(fit$coefficients)[-1]
patterns <- c("\\^", "\\:")
extraArgs <- c()
for (p in patterns) {
# If no detecting of a pattern, then is INDEP ARG
testExtra <- str_detect(allNames, p)
extraArgs <- c(extraArgs, allNames[testExtra])
}
indicesNotExtraArgs <- which(!allNames %in% extraArgs)
args <- allNames(indicesNotExtraArgs)
return(args)
}
findSimpleArgs(gas.lm   )
findSimpleArgs <- function(fit){
allNames <- names(fit$coefficients)[-1]
patterns <- c("\\^", "\\:")
extraArgs <- c()
for (p in patterns) {
# If no detecting of a pattern, then is INDEP ARG
testExtra <- str_detect(allNames, p)
extraArgs <- c(extraArgs, allNames[testExtra])
}
indicesNotExtraArgs <- which(!allNames %in% extraArgs)
args <- allNames[indicesNotExtraArgs]
return(args)
}
findSimpleArgs(gas.lm   )
ys <- function(x2) {
return((15582.54 + 0.-7823*5000 = 0.00000018*5000^2) +
(-523.134 + 0.00445*5000)*x2 + 8.84*x2^2)
}
ys(x2=GASTURBINE$CPRATIO)
ys(x2=GASTURBINE$CPRATIO[1])
ys <- function(x2) {
return((15582.54 + 0.07823*5000 = 0.00000018*5000^2) +
(-523.134 + 0.00445*5000)*x2 + 8.84*x2^2)
}
ys(x2=GASTURBINE$CPRATIO[1])
ys <- function(x2) {
return((15582.54 + 0.07823*5000 - 0.00000018*5000^2) +
(-523.134 + 0.00445*5000)*x2 + 8.84*x2^2)
}
ys(x2=GASTURBINE$CPRATIO[1])
ys(x2=GASTURBINE$CPRATIO)
g <- ggplot(GASTURBINE, aes(x = CPRATIO, y = allYs)) +
geom_point(shape=19, color="pink", size=3)
g #
allYS <- ys(x2=GASTURBINE$CPRATIO)
g <- ggplot(GASTURBINE, aes(x = CPRATIO, y = allYS)) +
geom_point(shape=19, color="pink", size=3)
g #
g <- ggplot(GASTURBINE, aes(x = CPRATIO, y = allYS)) +
geom_point(shape=19, color="magenta", size=3)
g #
patterns <- c("\\^", "\\:")
p = "\\^"
tup <- separateArgs(fit)
args <- tup[1]
extraArgs <- tup[2]
tup <- separateArgs(fit)
separateArgs <- function(fit){
allNames <- names(fit$coefficients)[-1]
patterns <- c("\\^", "\\:")
extraArgs <- c()
for (p in patterns) {
# If no detecting of a pattern, then is INDEP ARG
testExtra <- str_detect(allNames, p)
extraArgs <- c(extraArgs, allNames[testExtra])
}
indicesNotExtraArgs <- which(!allNames %in% extraArgs)
args <- allNames[indicesNotExtraArgs]
return(c(args, extraArgs))
}
tup <- separateArgs(fit)
args <- tup[1]
extraArgs <- tup[2]
extraArgs
separateArgs(fit)
data.frame(args, extraArgs)
separateArgs <- function(fit){
allNames <- names(fit$coefficients)[-1]
patterns <- c("\\^", "\\:")
extraArgs <- c()
for (p in patterns) {
# If no detecting of a pattern, then is INDEP ARG
testExtra <- str_detect(allNames, p)
extraArgs <- c(extraArgs, allNames[testExtra])
}
indicesNotExtraArgs <- which(!allNames %in% extraArgs)
args <- allNames[indicesNotExtraArgs]
return(data.frame(args, extraArgs))
}
tup <- separateArgs(fit)
separateArgs <- function(fit){
allNames <- names(fit$coefficients)[-1]
patterns <- c("\\^", "\\:")
extraArgs <- c()
for (p in patterns) {
# If no detecting of a pattern, then is INDEP ARG
testExtra <- str_detect(allNames, p)
extraArgs <- c(extraArgs, allNames[testExtra])
}
indicesNotExtraArgs <- which(!allNames %in% extraArgs)
args <- allNames[indicesNotExtraArgs]
return(list(args, extraArgs))
}
tup <- separateArgs(fit)
args <- tup[1]
extraArgs <- tup[2]
args
extraArgs
args <- tup[[1]]
args
extraArgs <- tup[[2]]
extraArgs
str_detect(extraArgs, p)
p
bodyArgs <- c()
testPattern <- str_detect(extraArgs, p)
ys <- function(x2) {
return((15582.54 + 0.07823*15000 - 0.00000018*15000^2) +
(-523.134 + 0.00445*15000)*x2 + 8.84*x2^2)
}
allYS <- ys(x2=GASTURBINE$CPRATIO)
g1 <- ggplot(GASTURBINE, aes(x = CPRATIO, y = allYS)) +
geom_point(shape=19, color="magenta", size=3)
g1 #
load("data/Exercises and Examples/SALES.Rdata")
library(ggplot2)
attach(SALES)
?sd
x.mean <- mean(SALES$SALESYR1)
x.i <- SALES$SALESYR1
x.i <- SALES$SALESYR1
n <- length(x.i)
x.mean <- mean(x.i)
x.sd <- sqrt(sum( (x.i - x.mean)^2 ) / (n-1) )
u.i <- (x.i - x.mean) / x.sd; u.i
sales.coded.lm <- lm(SALESYR2 ~ u.i, data=SALES)
summary(sales.coded.lm)
sales.lm <- lm(SALESYR2 ~ SALESYR1, data=SALES)
summary(sales.lm)
summary(sales.coded.lm)
summary(sales.lm)
summary(sales.coded.lm)
g1 <- ggplot(SALES, aes(x=SALESYR1, y = SALESYR2)) +
geom_point(shape=19, size=3, color="dodgerblue")
g1 #
g2 <- ggplot(SALES, aes(x=SALESYR1, y = SALESYR2)) +
g2 <- ggplot(SALES, aes(x=u.i, y = SALESYR2)) +
geom_point(shape=19, size=3, color="dodgerblue")
g2 #
g2 <- ggplot(SALES, aes(x=u.i, y = SALESYR2)) +
geom_point(shape=19, size=3, color="dodgerblue")
g2 #
g1 #
g2 #
x.mean
x.sd
sd(x.i)
cor(x.i, x.i^2)
cor(u.i, u.i^2)
sales.coded.lm <- lm(SALESYR2 ~ u.i + I(u.i^2), data=SALES)
summary(sales.coded.lm)
sales.lm <- lm(SALESYR2 ~ SALESYR1 + I(SALESYR1^2), data=SALES)
summary(sales.lm)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/")
load("data/Exercises and Examples/DIESEL.Rdata")
View(DIESEL)
attach(DIESEL)
diesel.lm <- lm(PERFORM ~ FUEL + BRAND, data=DIESEL)
summary(diesel.lm)
diesel.lm <- lm(PERFORM ~ FUEL + BRAND + FUEL:BRAND, data=DIESEL)
diesel.lm <- lm(PERFORM ~ FUEL + BRAND, data=DIESEL)
diesel.interact.lm <- lm(PERFORM ~ FUEL + BRAND + FUEL:BRAND, data=DIESEL)
summary(diesel.interact.lm)
B0 <- diesel.interact.lm$coef[1]; B0
B0 <- diesel.interact.lm$coef[[1]]; B0
summary(diesel.interact.lm)
B2 <- diesel.interact.lm$coef[[3]]; B2
B3 <- diesel.interact.lm$coef[[4]]; B3
B5 <- diesel.interact.lm$coef[[6]]; B5
mu_32 <- B0 + B2 + B3 + B5 #
mu_32 <- B0 + B2 + B3 + B5; mu_32 #
summary(diesel.lm)
diesel.lm$coefficients
B0 <- diesel.lm$coefficients[[1]]; B0
B2 <- diesel.lm$coefficients[[3]]; B2
B3 <- diesel.lm$coefficients[[4]]; B3
B0 + B2 + B3
mu_32 <- B0 + B2 + B3; mu_32
# same SSE as for ANOVA as one from SUMMARY
SSE <- function(fit) {
y <- fit$model[[1]]
yhat <- fit$fitted
return(sum( (y - yhat)^2 ))
}
# can get this value with anova table too:
# (under MeanSq Column and Resids Row - that is s^2)
standardErrorOfRegression <- function(fit) {
sse.value <- invisible(SSE(fit))
n <- length(fit$fitted)
kplusOne <- ncol(fit$model)
return (sqrt((sse.value) / (n - kplusOne)))
}
standardErrorOfSlope <- function(fit) {
x <- fit$model[[2]]
s <- standardErrorOfRegression(fit)
return (s / sqrt(SSxx(x)))
}
SSyy <- function(y) {
y.mean <- mean(y)
return ( sum( (y - y.mean)^2 ) )
}
SSxx <- function(x) {
x.mean <- mean(x)
return ( sum( (x - x.mean)^2 ) )
}
SSxy <- function(x, y) {
x.mean <- mean(x)
y.mean <- mean(y)
return ( sum( (x - x.mean) * (y - y.mean) ) )
}
#standardErrorOfRegression <- function(sse.value, n) {
#      return(sqrt(sse.value / (n - 2)))
#}
# OR
#a <- anova(lm)
#ss <- a$`Sum Sq`
#return(ss[length(ss)])
# OR
#s <- summary(r.lm)
#(1-s$r.squared)*SST(var$datamat$dc)
SST <- function(fit) {
y <- fit$model[[1]]
y.mean <- mean(y)
return ( sum( (y - y.mean)^2 ) )
}
## Confidence interval for the Slope in Regression Model (multiple)
slopeCI <- function(fit, level=0.95) {
mat <- confint(fit, level=level)
df <- data.frame(as.numeric(mat[,1]), as.numeric(mat[,2]))
colnames(df) <- colnames(mat)
return(df)
}
#slopeCI <- function(fit, level = 0.95) {
#      slope <- fit$coefficients[[2]]
#      sB1 <- standardErrorOfSlope(fit)
#
#      # Calculate alpha for the t-statistic, and df
#      alpha <- 1 - level
#      n <- length(y)
#      df <- n - 2
#      t.alpha2 <- abs(qt(alpha/2, df))
#
#      # calculate conf.int
#      leftCI <- slope - t.alpha2 * sB1
#      rightCI <- slope + t.alpha2 * sB1
#
#      return( c(leftCI, rightCI) )
#}
# Confidence interval for the Mean when x = xp
# E(y) = yhat(xp) +- t(alpha/2,df) * s * sqrt(1/n + (xp - xmean)^2/SSxx)
## NOTE: can be found using R with this:
# predict(model, new = data.frame(x.name=x.value), interval="confidence", level=0.95)
meanCI <- function(fit, x.values=c(), level=0.95){
predictorNames <- names(fit$model)[-1]
df <- data.frame(rbind(x.values))
rownames(df) <- ""
colnames(df) <- predictorNames
return(predict(fit, new = df, interval="confidence", level=level))
}
predictCI <- function(fit, x.values, level=0.95){
predictorNames <- names(fit$model)[-1]
df <- data.frame(rbind(x.values))
rownames(df) <- ""
colnames(df) <- predictorNames
return(predict(fit, new = df, interval="prediction", level=level))
}
#meanCI <- function(fit, x.value, level=0.95) {
#      # finding the yhat value at a particular x-.value
#      yhat.at.xp <- fit$coeff[[2]] * x.value + fit$coeff[[1]]
#      yhat <- fit$fitted
#      x <- fit$model[[2]]
#      y <- fit$model[[1]]
#
#      # Finding the std error of regression, s
#      s <- standardErrorOfRegression(fit)
#
#      # Finding the t, alpha
#      alpha <- 1 - level
#      n <- length(y)
#      df <- n - 2
#      t.alpha2 <- abs(qt(alpha/2, df))
#
#      # Calculating the confidence interval.
#      leftCI <- yhat.at.xp - t.alpha2 * s * sqrt(1/n + (x.value - mean(x))^2 / SSxx(x))
#      rightCI <- yhat.at.xp + t.alpha2 * s * sqrt(1/n + (x.value - mean(x))^2 / SSxx(x))
#
#      return(c(leftCI, rightCI))
#}
# Confidence interval for the Predictor when x = xp
# yi = yhat(xp) +- t(alpha/2,df) * s * sqrt(1 + 1/n + (xp - xmean)^2/SSxx)
## NOTE: can be found using R with this:
# predict(model, new = data.frame(x.name=x.value), interval="prediction", level=0.95)
#predictCI <- function(fit, x.value, level=0.95) {
#      # finding the yhat value at a particular x-.value
#      yhat.at.xp <- fit$coeff[[2]] * x.value + fit$coeff[[1]]
#      yhat <- fit$fitted
#      x <- fit$model[[2]]
#      y <- fit$model[[1]]
#
#      # Finding the std error of regression, s
#      s <- standardErrorOfRegression(fit)
#
#      # Finding the t, alpha
#      alpha <- 1 - level
#      n <- length(y)
#      df <- n - 2
#      t.alpha2 <- abs(qt(alpha/2, df))
#
#      # Calculating the confidence interval.
#      leftCI <- yhat.at.xp - t.alpha2 * s * sqrt(1 + 1/n + (x.value - mean(x))^2 / SSxx(x))
#      rightCI <- yhat.at.xp + t.alpha2 * s * sqrt(1 + 1/n + (x.value - mean(x))^2 / SSxx(x))
#
#      return(c(leftCI, rightCI))
#}
# Given restricted and unrestricted models,
# do joint F-test but give Chi square instead of F
# k = number of restrictions = df1
# n - (k+1) = df2, n = sample size.
##### TODO: write the hypothesis tested: figure out the B# = B# = 0 etc.
# from the coefs that are missing in the reduced model.
####################################### TODO: check out EtaSq from DescTools
######################################## Use Anova() from car package.
NestedFandChiSqTest <- function(r.lm, u.lm){
# number of parameter difference
df1 = length(u.lm$coef) - length(r.lm$coef); df1
df2 = nrow(u.lm$model) - df1 - 1; df2
sse.r <- SSE(r.lm)
sse.c <- SSE(u.lm)
F.nested <- ((sse.r - sse.c) / df1) / ((sse.c / df2)); F.nested
chi.stat <- F.nested * df1
chi.p.value <- round(1 - pchisq(chi.stat, df=df1), 5)
f.p.value <- round(1 - pf(F.nested, df1=df1, df2=df2), 5)
cat("\n")
cat("#############################################################\n")
cat("####                 Analysis Of Variance                 ###\n")
cat("####    (F Test and Chi-Square Test for Nested Models)    ###\n")
cat("#############################################################\n")
cat("\n")
cat("χ2 statistic:                        ", chi.stat, "\n")
cat("p-value:                             ", chi.p.value, "\n")
cat("F statistic:                         ", F.nested, "\n")
cat("p-value:                             ", f.p.value, "\n\n")
return(invisible(data.frame(ChiSquare=chi.stat, ChiSqPValue=chi.p.value,
FStatistic=F.nested, FPvalue=f.p.value,
df1=df1, df2=df2)))
}
# The Global F-test for regression model fit.
FTest <- function(fit) {
sst = SST(fit)
sse = SSE(fit)
k = length(fit$coefficients) - 1
n = nrow(fit$model)
Fcrit <- ((sst - sse)/k) / (sse / (n-k-1))
p.value <- 1 - pf(Fcrit, df1=k, df2= n-k-1)
cat("\n")
cat("#############################################################\n")
cat("####                 Analysis Of Variance                 ###\n")
cat("####             (F Test The Regression Model)            ###\n")
cat("#############################################################\n")
cat("\n")
cat("F statistic:                         ", Fcrit, "\n")
cat("p-value:                             ", p.value, "\n\n")
df <- data.frame(FStatistic=Fcrit, PValue=p.value,
DFNumerator=k, DFDenominator=n-k-1)
rownames(df) <- ""
return(invisible(df))
}
meanCI(diesel.lm, x.values=c(0, 1, 1))
predict(diesel.lm, newdata = data.frame(c(0,1,1)))
predict(diesel.lm, newdata = data.frame(c(0,1,1)))
predict(diesel.lm, newdata = data.frame(rbind(c(0,1,1))))
summary(diesel.lm)
predict(diesel.lm, newdata = data.frame(FUELF2=0, FUELF3=1, BRANDB2=1))
predict(diesel.lm, newdata = data.frame(conc=seq(0,1,1)))
seq(0,1,1)
df = data.frame(rbind(c(0,1,1)))
df #
colnames(df) <- c("FUELF2", "FUELF3", "BRANDB2")
summary(diesel.lm)
df #
predict(diesel.lm, new=df)
diesel.lm$coefficients
diesel.lm$coefficients[1] + diesel.lm$coefficients[3] + diesel.lm$coefficients[4]
anova(diesel.lm, diesel.interact.lm)
NestedFandChiSqTest(diesel.lm, diesel.interact.lm)
r.lm <- diesel.lm
u.lm <- diesel.interact.lm
df1 = length(u.lm$coef) - length(r.lm$coef); df1
df2 = nrow(u.lm$model) - df1 - 1; df2
u.lm$model
df2 = nrow(u.lm$model) - df1 - 1; df2
df1 = length(u.lm$coef) - length(r.lm$coef); df1
nrow(u.lm$model)
g = length(u.lm$coef) - length(r.lm$coef)
k = length(u.lm$coef)
df2 = nrow(u.lm$model) - k - 1; df2
sse.r <- SSE(r.lm)
sse.c <- SSE(u.lm)
df1 = g #
F.nested <- ((sse.r - sse.c) / df1) / ((sse.c / df2)); F.nested
k = length(u.lm$coef) - 1
df2 = nrow(u.lm$model) - k - 1
F.nested <- ((sse.r - sse.c) / df1) / ((sse.c / df2)); F.nested
chi.stat <- F.nested * df1
chi.p.value <- round(1 - pchisq(chi.stat, df=df1), 5)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/FORMULAS.R', echo=TRUE)
NestedFandChiSqTest(diesel.lm, diesel.interact.lm)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 5 - Principles of Model Building/Example_5.10_InteractionCategorical_diesel.R', echo=TRUE)
anova(diesel.lm, diesel.interact.lm)
NestedFandChiSqTest(diesel.lm, diesel.interact.lm)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 5 - Principles of Model Building/Example_5.3_prodqual.R', echo=TRUE)
NestedFandChiSqTest(reduced.lm, prodqual.lm)
anova(reduced.lm, prodqual.lm)
load("data/Exercises and Examples/STREETVN.Rdata")
attach(STREETVN)
# Fitting complete second order model
street.lm <- lm(EARNINGS ~ AGE + HOURS + AGE*HOURS + I(AGE^2) + I(HOURS^2),
data=STREETVN)
summary(street.lm)
reduced.lm <- lm(EARNINGS ~ AGE + HOURS, data=STREETVN)
summary(reduced.lm)
anova(reduced.lm, street.lm)
NestedFandChiSqTest(reduced.lm, street.lm)
detach(STREETVN)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 5 - Principles of Model Building/exercise_5.17_quasar.R', echo=TRUE)
attach(GASTURBINE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 5 - Principles of Model Building/exercise_5.8_5.19_gasturbine.R', echo=TRUE)
FTest(gas.lm)
summary(gas.lm)
