df[6,1] == df[6,2] == df[6,3]
df[6,1] == df[6,2] || df[6,1] == df[6,3] || df[6,2] == df[6,3]
rolls <- cbind(dice1, dice2, dice3)
c = -
c = 0
c = 0
c += 1
probFaceValuesAllDifferent
probFaceValuesAllDifferent <- count / N;
probFaceValuesAllDifferent
probFaceValuesAllDifferent <- count / N;
rolls <- cbind(dice1, dice2, dice3)
#unique(df[6,])
count <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count = count + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent <- count / N;
probFaceValuesAllDifferent
count <- 0
unique(rolls)
head(unique(rolls))
head(rolls)
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
count /
count / N
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
count / N
count <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count = count + 1
}
}
count
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
warnings()
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count = count + 1
}
}
count
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferen.1
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
assertthat::count.1 == count.2
assertthat(count.1 == count.2)
assert_that(count.1 == count.2)
count.1 == count.2
probFaceValuesAllDifferent.2
1 - pbinom(100, size=105, n = 0.10)
1 - pbinom(100, size=105, prob = 0.10)
pbinom(100, size = 105, prob = 0.10, lower.tail=FALSE)
1 - pbinom(100, size=105, prob = 0.90)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
ppois(11, lambda=10, lower.tail = FALSE)
1 - ppois(11, lambda=10)
p = ppois(11, lambda=10, lower.tail = FALSE)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
1 - pbinom(2, size=8, prob=p)
p = pgeom(2, prob=0.8, lower.tail = FALSE)
p = pgeom(2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
1 - pgeom(2, prob=0.8)
p = pgeom(q=3, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
?pgeom
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
N <- 10^4
dice1 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice2 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice3 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
diceSum <- dice1 + dice2 + dice3
# part a) Probability that sum of face values < 10
probLessTen <- sum(diceSum < 10) / N; probLessTen
rolls <- cbind(dice1, dice2, dice3)
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
probFaceValuesAllDifferent.2
# Test to make sure: Should be true, the two methods yield the same answer.
count.1 == count.2
1 - pbinom(100, size=105, prob = 0.90)
# method 2 of calculating
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Assignment2_questions_1_4_5.R', echo=TRUE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
1 - ppois(11, lambda=10)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
# method 2
1 - ppois(11, lambda=10)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
# method 2
1 - pbinom(2, size=8, prob=p)
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
# Method 2
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
# Method 2
1 - pbinom(3, size=10, prob=p)
p = pgeom(q=0, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(2, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(0, prob=0.8) # P(X >= 2) = P(X <= 1)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 6, 7 - Variable Screening, Transformations/lecturedata/")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/PLOTTING.R')
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/FORMULAS.R')
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Rfunctions.R')
library(ggplot2)
options(digits=10, show.signif.stars = F)
pigData <- read.table("carc.txt", header=TRUE)
pairs(pigData,lower.panel=panel.smooth, upper.panel=panel.cor)
formL <- formula(~ 1)
formU <- formula(~ Wt + fdP2 + fd34 + fdH1 + fdH2 + mdP2 + md34)
start.model <- lm(LMpc ~ 1, data=pigData)
step.forward.model <- step(start.model, direction = "forward",
scope=list(lower=formL, upper=formU))
summary(step.forward.model)
betaCI(step.forward.model)
start.model <- lm(LMpc ~ Wt + fdP2 + fd34 + fdH1 + fdH2 + mdP2 + md34,
data=pigData)
start.model <- lm(LMpc ~ Wt + fdP2 + fd34 + fdH1 + fdH2 + mdP2 + md34,data=pigData)
step.back.model <- step(start.model)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 6, 7 - Variable Screening, Transformations/lecturedata/")
poppyData <- read.table("poppy.txt", header=TRUE)
View(poppyData)
View(poppyData)
with(poppyData, tapply(count, list(block, treatment), mean))
with(poppyData, tapply(count, list(block, treat), mean))
with(poppyData, tapply(count, list(block, treat), mean, sd))
with(poppyData, tapply(count, list(block, treat), c(mean, sd)))
with(poppyData, tapply(count, list(block, treat), function(x){
c(MEAN=mean(x), SD=sd(x))
}))
with(poppyData, aggregate(count ~ blcok + treat, FUN=function(x)
c(MEAN=mean(x), SD=sd(x)) ))
with(poppyData, aggregate(count ~ block + treat, FUN=function(x)
c(MEAN=mean(x), SD=sd(x)) ))
with(poppyData, tapply(count, list(block, treat), mean))
means <- with(poppyData, tapply(count, list(treat, block), mean))
sds <- with(poppyData, tapply(count, list(treat, block), sd))
cbind(means, sds)
poppyData$treat <- factor(poppyData$treat)
poppyData$block <- factor(poppyData$block)
means <- with(poppyData, tapply(count, list(treat, block), mean))
sds <- with(poppyData, tapply(count, list(treat, block), sd))
cbind(means, sds)
means <- with(poppyData, tapply(count, list(treat, block)))
means
means <- with(poppyData, tapply(count, list(treat, block), mean))
means
groupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
meanAF <- with(groupMeans, tapply(treat, list(block), mean))
class(groupMeans)
groupMeans <- data.frame(groupMeans)
colnames(groupMeans) <- "Block"
groupMeans
groupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
colname(cbind(groupMeans)) <- "Block"
with(poppyData, table(count))
with(poppyData, table(count, list(block, treat)))
rolls.obs <- c(3, 7, 5, 10, 2, 3)
n <- sum(rolls.obs)
rolls.prop <- c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6)
rolls.exp <- n * rolls.prop; rolls.exp
dice.test <- chisq.test(x=rolls.obs, p=rolls.prop); dice.test
dice.test$observed
dice.test$expected
dice.test$residuals # pearson residuals
# manual residuals:
os <- dice.test$observed; es <- dice.test$expected
rs <- (os - es) / sqrt(es); rs
df <- length(rolls.obs) - 1; df
cutoff <- sqrt( (df-1)/df ); cutoff # limit over which Pearson resids are too big
### Deviance and p-value
LikelihoodRatioTableTest(rolls.obs)
## Deviance residuals
dev.res.j <- devianceResiduals(os, es); dev.res.j
## make nice output table
output <- round(cbind(cell.j=1:6, O.j=os, E.j=es, res.j=rs, dev.res.j=dev.res.j), 3)
output <- as.data.frame(output); output
source('/datascience/projects/statisticallyfit/github/R/RStatistics/FORMULAS.R')
rolls.obs <- c(3, 7, 5, 10, 2, 3)
n <- sum(rolls.obs)
rolls.prop <- c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6)
rolls.exp <- n * rolls.prop; rolls.exp
dice.test <- chisq.test(x=rolls.obs, p=rolls.prop); dice.test
dice.test$observed
dice.test$expected
dice.test$residuals # pearson residuals
# manual residuals:
os <- dice.test$observed; es <- dice.test$expected
rs <- (os - es) / sqrt(es); rs
df <- length(rolls.obs) - 1; df
cutoff <- sqrt( (df-1)/df ); cutoff # limit over which Pearson resids are too big
### Deviance and p-value
LikelihoodRatioTableTest(rolls.obs)
dev.res.j <- devianceResiduals(os, es); dev.res.j
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Chapter 6, 7 - Variable Screening, Transformations/lecturedata/")
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/PLOTTING.R')
source('/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/FORMULAS.R')
source("/datascience/projects/statisticallyfit/github/R/RStatistics/STAT210 Statistical Modelling and Experimental Design/Rfunctions.R")
options(digits=10, show.signif.stars = FALSE)
poppyData <- read.table("poppy.txt", header=TRUE)
poppyData$treat <- factor(poppyData$treat)
poppyData$block <- factor(poppyData$block)
groupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
groupMeans <- data.frame(groupMeans)
groupMeans
groupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
rowMeans(groupMeans)
library(Matrix)
install.packages("matrixStats")
library(matrixStats)
groupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
transform(groupMeans, MEANS=rowMeans(groupMeans), SD=rowSds())
transform(X=groupMeans, MEANS=rowMeans(groupMeans), SD=rowSds())
transform(X=groupMeans, MEANS=rowMeans(groupMeans))
groupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
colNames <- colnames(groupMeans)
groupMeans <- data.frame(groupMeans)
colnames(groupMeans) <- colNames
groupMeans
transform(X=groupMeans, MEANS=rowMeans(groupMeans))
transform(X=groupMeans, MEANS=rowMeans(groupMeans, na.rm=TRUE))
?transform
?"matrixStats"
?transform
transform(airquality, Ozone = -Ozone)
transform(X=groupMeans, MEANS=rowMeans(groupMeans, na.rm=TRUE))
transform(`_data`=groupMeans, MEANS=rowMeans(groupMeans, na.rm=TRUE))
groupMeans
with(groupMeans, transform(MEANS=rowMeans(groupMeans, na.rm=TRUE))
with(groupMeans, transform(MEANS=rowMeans(groupMeans, na.rm=TRUE)))
with(groupMeans, transform(MEANS=rowMeans(groupMeans, na.rm=TRUE)))
theGroupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
theGroupMeans <- data.frame(theGroupMeans)
colnames(theGroupMeans) <- colNames
theGroupMeans
with(theGroupMeans, transform(MEANS=rowMeans(groupMeans, na.rm=TRUE)))
transform(`_data`=theGroupMeans, MEANS=rowMeans(theGroupMeans),
SD=rowSds(theGroupMeans)))
transform(`_data`=theGroupMeans, MEANS=rowMeans(theGroupMeans),
SD=rowSds(theGroupMeans))
theGroupMeans = transform(`_data`=theGroupMeans, MEANS=rowMeans(theGroupMeans))
theGroupMeans = transform(`_data`=theGroupMeans, SD=rowSds(theGroupMeans))
theGroupMeans
theGroupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
theGroupMeans = transform(`_data`=theGroupMeans, MEANS=rowMeans(theGroupMeans))
theGroupMeans = transform(`_data`=theGroupMeans, SD=rowSds(theGroupMeans))
class(theGroupMeans)
theGroupMeans = transform(`_data`=as.matrix(theGroupMeans), SD=rowSds(theGroupMeans))
theGroupMeans <- as.matrix(theGroupMeans)
theGroupMeans = transform(`_data`=theGroupMeans, SD=rowSds(theGroupMeans))
theGroupMeans
theGroupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
theGroupMeans = transform(`_data`=theGroupMeans, MEANS=rowMeans(theGroupMeans))
theGroupMeans <- as.matrix(theGroupMeans)
theGroupMeans = transform(`_data`=theGroupMeans, SD=rowSds(theGroupMeans))
theGroupMeans
any(is.na(poppyData))
poppy1.lm <- lm(count ~ block + treat, data=poppyData)
betaCI(poppy1.lm)
poppyData <- read.table("poppy.txt", header=TRUE)
poppyData$treat <- factor(poppyData$treat)
poppyData$block <- factor(poppyData$block)
poppy1.lm <- lm(count ~ block + treat, data=poppyData)
betaCI(poppy1.lm)
poppy1.lm <- lm(count ~ block + treat-1, data=poppyData)
betaCI(poppy1.lm)
poppyData <- read.table("poppy.txt", header=TRUE)
poppyData$treat <- factor(poppyData$treat)
poppyData$block <- factor(poppyData$block)
poppy1.lm <- lm(count ~ block + treat, data=poppyData)
betaCI(poppy1.lm)
poppy1.lm <- lm(count ~ block/treat-1, data=poppyData)
betaCI(poppy1.lm)
poppy1.lm <- lm(count ~ block + treat + block:treat, data=poppyData)
betaCI(poppy1.lm)
poppy1.lm <- lm(count ~ block + treat + block:treat, data=poppyData)
betaCI(poppy1.lm)
poppy1.lm <- lm(count ~ block + treat, data=poppyData)
betaCI(poppy1.lm)
summary(poppy1.lm)
autoplot(poppy1.lm, which=1:3)
shapiro.test(poppy1.lm$residuals)
theGroupMeans
theGroupMeans <- with(poppyData, tapply(count, list(treat, block), mean))
theGroupMeans = transform(`_data`=theGroupMeans, MEANS=rowMeans(theGroupMeans))
theGroupMeans <- as.matrix(theGroupMeans)
theGroupMeans = transform(`_data`=theGroupMeans, SD=rowSds(theGroupMeans))
theGroupMeans
subset(poppyData == "A")
poppyData
poppyData[poppyData=="A"]
poppyData[poppyData=="A",]
poppyData[poppyData$treat=="A",]
as <- poppyData[poppyData$treat=="A",]
sd(as$count)
sd(as$count)^2
As <- poppyData[poppyData$treat=="A",]
As <- poppyData[poppyData$treat=="A",]; As
with(As, tapply(count, block, mean))
mean(As$count)
with(poppyData, tapply(count, list(block, treat), mean))
with(poppyData, tapply(count, list(treat, block), mean))
t <- with(poppyData, tapply(count, list(treat, block), mean))
table(t)
prop.table(t)
t
t <- with(poppyData, tapply(count, list(treat, block), sd))
t
As <- poppyData[poppyData$treat=="A",]; As
mean(As$count)
mean(As$count, As$count)
mean(c(As$count, As$count))
Bs <- poppyData[poppyData$treat=="B",]
Cs <- poppyData[poppyData$treat=="C",]
Ds <- poppyData[poppyData$treat=="D",]
Es <- poppyData[poppyData$treat=="E",]
Fs <- poppyData[poppyData$treat=="F",]
mean(c(As,Bs,Cs,Ds,Es,Fs))
tapply(c(As,Bs,Cs,Ds,Es,Fs), mean)
mean(c(As,Bs,Cs,Ds,Es,Fs), 'r')
mean(c(As,Bs,Cs,Ds,Es,Fs), 'c')
A=[1,2,10;7,7.1,7.01];
mean(A)
mean(A,'r')
mean(A,'c')
groupCounts <- with(poppyData, tapply(count, list(block, treat), mean))
groupCounts
groupCounts <- with(poppyData, tapply(count, list(treat, block), mean))
groupCounts
mean(groupCounts[1,])
sd(groupCounts[1,])
means <- 0
sds <- 0
for(i in 1:nrow(groupCounts)){
means <- c(means, mean(groupCounts[i,]))
sds <- c(sds, sd(groupCounts[i,]))
}
cbind(groupCounts, means, sds)
cbind(groupCounts, MEAN=means, SD=sds)
data.frame(groupCounts, MEAN=means, SD=sds)
data.frame(groupCounts, MEAN=means, SD=sds)
data.frame(groupCounts, means, sds)
cbind(groupCounts, means, sds)
means <- c()
sds <- c()
for(i in 1:nrow(groupCounts)){
means[i] <- mean(groupCounts[i,])
sds[i] <- sd(groupCounts[i,])
}
cbind(groupCounts, means, sds)
groupData <- cbind(groupCounts, means, sds)
groupData
sqrt(413)
groupCounts
rowMeans(groupCounts)
rowSds(groupCounts)
rowMeans(poppyData)
rowMeans(as.matrix(poppyData))
sqrt(groupCounts)
rowMeans(sqrt(groupCounts))
ln(groupCounts)
log(1)
log(exp(1))
transCompare = data.frame(meansY=rowMeans(groupCounts), varsY=rowVars(groupCounts),
meansSqrtY=rowMeans(sqrt(groupCounts)),
varsSqrtY=rowVars(sqrt(groupCounts)),
meansLnY=rowMeans(log(groupCounts)),
varsLnY=rowVars(log(groupCounts)))
transCompare
attach(transCompare)
Fmaxes <- c(max(varsY) / min(varsY), max(varsSqrtY)/min(varsSqrtY),
max(varsLnY)/min(varsLnY))
Fmaxes
max(varsLnY)
min(varsLnY)
class(transCompare)
Fmaxes
detach(transCompare)
poppy.sqrt.lm <- lm(sqrt(count) ~ block + treat, data=poppyData)
betaCI(poppy.sqrt.lm)
pred.df <- data.frame(block=1, treat=LETTERS[1:6])
pred.df$block <- factor(pred.df$block)
pred.df
preds <- predict(poppy.sqrt.lm, newdata=pred.df, interval="confidence")
preds
preds <- predict(poppy.sqrt.lm, newdata=pred.df, interval="confidence", type="response")
preds
pred.df <- cbind(pred.df, preds)
pred.df
pred.df$backT_fit <- pred.df$fit^2
pred.df$backT_lwr <- pred.df$lwr^2
pred.df$backT_upr <- pred.df$upr^2
pred.df
library(gplots)
M = lm(mpg ~ ., data=mtcars)
M #
cint <- confint(M, level=0.95)
cint #
co <- cbind(coefficients(M), summary(m)$coef[,4])
co <- cbind(coefficients(M), summary(M)$coef[,4])
co #
summary(M)$coef #
cind[order(co[,2], )]
cint[order(co[,2], )]
cint[order(co[,2] ), ]
cint.ord <- cint[order(co[,2] ), ]
co <- co[order(co[,2]), ]
barplot2(co[,1], plot.ci=TRUE, ci.l=cint.ord[,1], ci.u = cint.ord[,2], horiz=TRUE)
d=data.frame(drink=c("coffee","tea","water"), mean=c(3,6,2), lower=c(2.6,5.6,1.8), upper=c(3.5,6.3,2.8))
ggplot() +
geom_errorbar(data=d, mapping=aes(x=drink, ymin=upper, ymax=lower), width=0.2, size=1, color="blue") +
geom_point(data=d, mapping=aes(x=drink, y=mean), size=4, shape=21, fill="white") +
opts(title="geom_errorbar", plot.title=theme_text(size=40, vjust=1.5))
d=data.frame(drink=c("coffee","tea","water"), mean=c(3,6,2), lower=c(2.6,5.6,1.8), upper=c(3.5,6.3,2.8))
ggplot() +
geom_errorbar(data=d, mapping=aes(x=drink, ymin=upper, ymax=lower), width=0.2, size=1, color="blue") +
geom_point(data=d, mapping=aes(x=drink, y=mean), size=4, shape=21, fill="white")
library(ggpubr)
install.packages("ggpubr")
library(nlme)
Milk
data(Milk)
head(Milk)
View(Milk)
ggplot(Milk, aes(x=Time, y=protein)) +
stat_summary()
View(poppyData)
ggplot(poppyData, aes(x=count, y=treat)) + stat_summary()
q()
