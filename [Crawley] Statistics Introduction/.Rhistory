points(x3, dhyper(x=x3, m=10, n=20, k=15), pch=19, col="thistle1")
points(x3, dhyper(x=x3, m=10, n=20, k=15), pch=19, col="mediumvioletred")
points(x3, dhyper(x=x3, m=10, n=20, k=15), pch=19, col="thistle1")
points(x3, dmultinom(x=x3, size=10, prob=(x3)/10))
dbinom(x=3, size=10, prob=1/5)
dpois(x=3, lambda=10*1/5)
dbinom(x=5, size=20, prob=0.05)
dpois(x=5, lambda=20*0.05)
pbinom(x=3, size=20, prob=0.05)
pbinom(q=3, size=20, prob=0.05)
1-pbinom(q=2, size=20, prob=0.05)
x <- 0:4
heads <- 0:4
prob.heads <- dbimom(x=heads, size=100, prob=1/2)
prob.heads <- dbinom(x=heads, size=100, prob=1/2)
1/16
prob.heads <- dbinom(x=heads, size=4, prob=1/2)
mean(prob.heads)
exp <- heads*prob.heads
exp <- sum(heads*prob.heads)
s <- sqrt(sum(heads^2*prob.heads))
s <- sqrt(sum(heads^2*prob.heads)-exp^2)
dbinom(x=2, size=5, prob=0.05)
1-pbinom(2, 5, 0.05)
dbinom(5,5,0.05)
1-pbinom(14, 20, 1/5)
prob=1/5
size=20
1-pbinom(14, 20, 2/15)
1-pbinom(14, 20, 1/15)
1-pbinom(14, 20, 1/5)
1-pbinom(14, 20, 1/2)
dbinom(8, 8, 0.77)
1-pbinom(4, 8, 0.77)
dbinom(3, 8, 0.77)
pbinom(2, 10, 0.103)
1-pbinom(5, 10, 0.103)
1-pbinom(5, 10, (1-0.103))
pbimom(5, 10, 0.103)
pbinom(5, 10, 0.103)
pbinom(5, 10, (1-0.103))
dbinom(10, 10, 0.103)
1-dbinom(10, 10, 0.103)
dbinom(0, 10, 0.103)
pbinom(5,10, 0.103)
pbinom(3, 7, 0.75)
dbinom(0, 5, 0.521)
1-pbinom(2, 5, 0.521)
1-pbinom(3, 5, 0.521)
pbinom(1, 5, 0.521)
dbinom(2, 5, 0.4)
pbinom(3, 5, 0.4)
1-pbinom(1, 5, 0.4)
pbinom(1, 5, 0.6)
pbinom(1, 5, 0.4)
pbinom(2, 5, 0.4)
dbinom(6, 12, 0.26)
1-pbinom(5, 12, 0.26)
pbinom(4, 12, 0.26)
dbinom(5, 10, 0.53)
1-pbinom(4, 10, 0.53)
1-pbinom(4, 10, 0.47)
1-pbinom(4, 10, 0.53)+1-pbinom(4, 10, 0.47)
pbinom(4, 10, 0.53)
dbinom(5, 18, 0.25)
dbinom(9, 14, 0.63)
pbinom(3, 10, 1/3)
dbinom(12, 20, 0.58)
1-pbinom(2, 5, 0.13)
dbinom(2, 7, 0.14) + dbinom(3, 7, 0.14)
curve(dbinom(x, 4, 0.3), xlim=c(-5, 5))
x <- -5:5
plot(x, dbinom(x, 4, 0.3), pch=19, col="deeppink1")
plot(x, dbinom(x, 4, 0.3), pch=19, col="orchid1")
library(shiny)
q()
getwd()
setwd("/datascience/projects/statisticallyfit/github/
learningprogramming/R/StatisticsIntroUsingR_Crawley")
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/StatisticsIntroUsingR_Crawley")
getwd()
yvals <- read.csv("data/yvalues.csv")
attach(yvals)
hist(y)
hist(yvals)
yvals
attach(yvals)
detach(yvals)
y
detach(yvals)
y
attach(yvals)
y
hist(y)
hist(y, main="")
library(ISwR)
library(ISwR)
getwd()
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/IntroductionToStatisticsWithR_Dalgaard")
library(ISwR)
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/IntroductionToStatisticsWithR")
library(ISwR)
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/StatisticsIntroUsingR_Crawley")
setwd("/home/statisticallyfit")
library(ISwR)
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/StatisticsIntroUsingR_Crawley")
yvals <- read.csv("data/yvalues.csv")
attach(yvals)
detacj(yvals)
detach(yvals)
hist(y)
y
yvals <- read.csv("data/yvalues.csv")
y
hist(y)
y
hist(y)
arithmetic.mean <- function(x) sum(x)/length(x)
arithmetic.mean(y)
sorted <- sort(y)
length(y)
data <- c(1,2,3,4,5)
length(data)/2
sorted[ceiling(length(y)/2)]
sort(y)[ceiling(length(y)/2)]
data <- c(1,2,3,4,5, 6)
length(data)/3
length(data)/2
median <- function(x) {
if(length(x) %%2 == 0)
(sort(x)[ceiling(length(x)/2)] + sort(x)[ceiling(1+length(x)/2)])/2
else
sort(x)[ceiling(length(x)/2)]
}
median(y)
med <- function(x) {
if(length(x) %%2 == 0)
(sort(x)[ceiling(length(x)/2)] + sort(x)[ceiling(1+length(x)/2)])/2
else
sort(x)[ceiling(length(x)/2)]
}
med(y)
y
hist(y)
library(ISwR)
setwd("/home/statisticallyfit")
hist(y)
setwd("/home/statisticallyfit")
hist(y)
q()
library(extrafont)
font_import()
fonts()
pdf("plot_cm.pdf", family="CM Roman", width=5.5, height=5)
curve(dnorm, from=-3, to=3, main="Normal Distribution")
text(x=0, y=0.1, cex=1.5, expression(italic(y == frac(1, sqrt(2 * pi)) *
e ^ {-frac(x^2, 2)} )))
dev.off()
embed_fonts("plot_cm.pdf", outfile="plot_cm_embed.pdf")
" SITUATIONS:
(1) if there is one factor with 3 or more levels, use one-way ANOVA
(2) if 1 factor with 2 levels, use t-test (F = t^2)
(3) if 2 or more factors, use two or three way ANOVA
(4) factorial design: used if there is replication at each level
in a multi-way ANOVA to test if the response to one factor depends
on the level of another factor. "
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/StatisticsIntroUsingR_Crawley")
# (1) ONE-WAY ANOVA
oneway <- read.csv("data/oneway.csv")
attach(oneway)
oneway
plot(1:20, ozone, ylim=c(0,8), ylab="y", xlab="order", pch=19, col="red")
abline(h=mean(ozone), col="blue")
# segments
for(i in 1:20)
lines(c(i, i), c(mean(ozone), ozone[i]), col="green")
# look at departure of data from means of Garden A and B
plot(ozone, ylim=c(0, 8), ylab="y", xlab="order", pch=19, bg=as.numeric(garden))
abline(h=mean(ozone[garden=="A"]))
abline(h=mean(ozone[garden=="B"]), col="red")
# segments
# this code with index[i] works since data was plotted in order
index <- 1:length(ozone)
for(i in 1:length(index)) {
if(garden[i] == "A")
lines(c(index[i], index[i]), c(mean(ozone[garden=="A"]), ozone[i]))
else
lines(c(index[i], index[i]), c(mean(ozone[garden=="B"]), ozone[i]), col="red")
}
# ANOVA analysis: is this difference in mean ozone in A and B significantly big? Or could it have occurred by chance alone?
# IMPORTANT: if means are significantly different, sum of squares from individual treatment means is smaller than sum of squares from overall mean
# SSE = variation within the sample (made of many SSEs for each sample)
# SSA = variation between each sample mean
# SSY = SSA + SSE
SSY <- sum((ozone - mean(ozone))^2); SSY
SSE <-
sum((ozone[garden=="A"] - mean(ozone[garden=="A"]))^2) +
sum((ozone[garden=="B"] - mean(ozone[garden=="B"]))^2); SSE
SSA <- SSY - SSE; SSA
# build ANOVA table
varY <- SSY/19; varY # total
varE <- SSE/18; varE # error
varA <- SSA/1; varA # garden
"
H0: mu1 = mu2 = mu3 ....
H1: at least one mean from the sample groups is different"
# If the variation between sample means is significantly greater than variation within each sample, then the  means must be different.
f.ratio <- varA/varE; f.ratio
1 - pf(f.ratio, df1=1, df2=18) # therefore, the two means are significantly different
# Do the easy way
summary(aov(ozone~garden))
# df residuals = k(n-1) = (2 garden levels) * (10 replicates per garden - 1) = 2(10-1) = 2* 9 = 18
# Do graphical check of assumptions of model (constant variance and normal errors)
plot(aov(ozone~garden))
# first plot - shows that variances are identical in the two treatments
# second plot: values within each treatment group are normal
# third plot: residuals show constant variance
# fourth plot: attention to the values with large residuals
# Finding SSA directly (shortcut)
cbind(ozone[garden=="A"], ozone[garden=="B"])
tapply(ozone, garden, sum)
T1 <- 30; T2 <- 50
# shortcut SSA = sum(Ti^2)/n - (sum(y))^2/(kn)
SSA <- (30^2 + 50^2)/10 - (sum(ozone))^2/(2*10); SSA
# long way SSA <- n * sum((individual means - overall mean)^2)
SSA <- 10 * sum((mean(ozone[garden=="A"]) - mean(ozone))^2 +
(mean(ozone[garden=="B"]) - mean(ozone))^2)
# SSY = sum((y - overall mean)^2)
SSY <- sum((ozone - mean(ozone))^2); SSY
# SSE = sum((y - individual mean)^2) for each of the k levels in the factor
SSE
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/RStats/learnstats/crawleybookcode")
" SITUATIONS:
(1) if there is one factor with 3 or more levels, use one-way ANOVA
(2) if 1 factor with 2 levels, use t-test (F = t^2)
(3) if 2 or more factors, use two or three way ANOVA
(4) factorial design: used if there is replication at each level
in a multi-way ANOVA to test if the response to one factor depends
on the level of another factor. "
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/RStats/learnstats/crawleybookcode")
# (1) ONE-WAY ANOVA
oneway <- read.csv("data/oneway.csv")
attach(oneway)
oneway
plot(1:20, ozone, ylim=c(0,8), ylab="y", xlab="order", pch=19, col="red")
abline(h=mean(ozone), col="blue")
# segments
for(i in 1:20)
lines(c(i, i), c(mean(ozone), ozone[i]), col="green")
# look at departure of data from means of Garden A and B
plot(ozone, ylim=c(0, 8), ylab="y", xlab="order", pch=19, bg=as.numeric(garden))
abline(h=mean(ozone[garden=="A"]))
abline(h=mean(ozone[garden=="B"]), col="red")
# segments
# this code with index[i] works since data was plotted in order
index <- 1:length(ozone)
for(i in 1:length(index)) {
if(garden[i] == "A")
lines(c(index[i], index[i]), c(mean(ozone[garden=="A"]), ozone[i]))
else
lines(c(index[i], index[i]), c(mean(ozone[garden=="B"]), ozone[i]), col="red")
}
# ANOVA analysis: is this difference in mean ozone in A and B significantly big? Or could it have occurred by chance alone?
# IMPORTANT: if means are significantly different, sum of squares from individual treatment means is smaller than sum of squares from overall mean
# SSE = variation within the sample (made of many SSEs for each sample)
# SSA = variation between each sample mean
# SSY = SSA + SSE
SSY <- sum((ozone - mean(ozone))^2); SSY
SSE <-
sum((ozone[garden=="A"] - mean(ozone[garden=="A"]))^2) +
sum((ozone[garden=="B"] - mean(ozone[garden=="B"]))^2); SSE
SSA <- SSY - SSE; SSA
# build ANOVA table
varY <- SSY/19; varY # total
varE <- SSE/18; varE # error
varA <- SSA/1; varA # garden
"
H0: mu1 = mu2 = mu3 ....
H1: at least one mean from the sample groups is different"
# If the variation between sample means is significantly greater than variation within each sample, then the  means must be different.
f.ratio <- varA/varE; f.ratio
1 - pf(f.ratio, df1=1, df2=18) # therefore, the two means are significantly different
# Do the easy way
summary(aov(ozone~garden))
# df residuals = k(n-1) = (2 garden levels) * (10 replicates per garden - 1) = 2(10-1) = 2* 9 = 18
# Do graphical check of assumptions of model (constant variance and normal errors)
plot(aov(ozone~garden))
# second plot: values within each treatment group are normal
# third plot: residuals show constant variance
# fourth plot: attention to the values with large residuals
# Finding SSA directly (shortcut)
cbind(ozone[garden=="A"], ozone[garden=="B"])
tapply(ozone, garden, sum)
T1 <- 30; T2 <- 50
# shortcut SSA = sum(Ti^2)/n - (sum(y))^2/(kn)
SSA <- (30^2 + 50^2)/10 - (sum(ozone))^2/(2*10); SSA
# long way SSA <- n * sum((individual means - overall mean)^2)
SSA <- 10 * sum((mean(ozone[garden=="A"]) - mean(ozone))^2 +
(mean(ozone[garden=="B"]) - mean(ozone))^2)
# SSY = sum((y - overall mean)^2)
SSY <- sum((ozone - mean(ozone))^2); SSY
# SSE = sum((y - individual mean)^2) for each of the k levels in the factor
SSE
oneway <- read.csv("data/oneway.csv")
attach(oneway)
detach(oneway)
detach(oneway)
detach(oneway)
attach(oneway)
oneway
plot(1:20, ozone, ylim=c(0,8), ylab="y", xlab="order", pch=19, col="red")
abline(h=mean(ozone), col="blue")
for(i in 1:20)
lines(c(i, i), c(mean(ozone), ozone[i]), col="green")
plot(ozone, ylim=c(0, 8), ylab="y", xlab="order", pch=19, bg=as.numeric(garden))
abline(h=mean(ozone[garden=="A"]))
abline(h=mean(ozone[garden=="B"]), col="red")
index <- 1:length(ozone)
for(i in 1:length(index)) {
if(garden[i] == "A")
lines(c(index[i], index[i]), c(mean(ozone[garden=="A"]), ozone[i]))
else
lines(c(index[i], index[i]), c(mean(ozone[garden=="B"]), ozone[i]), col="red")
}
SSY <- sum((ozone - mean(ozone))^2); SSY
SSE <-
sum((ozone[garden=="A"] - mean(ozone[garden=="A"]))^2) +
sum((ozone[garden=="B"] - mean(ozone[garden=="B"]))^2); SSE
SSA <- SSY - SSE; SSA
varY <- SSY/19; varY # total
varE <- SSE/18; varE # error
varA <- SSA/1; varA # garden
f.ratio <- varA/varE; f.ratio
1 - pf(f.ratio, df1=1, df2=18) # therefore, the two means are significantly different
summary(aov(ozone~garden))
summary(ozone~garden)
summary(lm(ozone~garden))
summary(aov(ozone~garden))
plot(aov(ozone~garden))
cbind(ozone[garden=="A"], ozone[garden=="B"])
ozone
tapply(ozone, garden, sum)
T1 <- 30; T2 <- 50
SSA <- (30^2 + 50^2)/10 - (sum(ozone))^2/(2*10); SSA
SSA <- 10 * sum((mean(ozone[garden=="A"]) - mean(ozone))^2 +
(mean(ozone[garden=="B"]) - mean(ozone))^2)
SSA <- 10 * sum((mean(ozone[garden=="A"]) - mean(ozone))^2 +
(mean(ozone[garden=="B"]) - mean(ozone))^2); SSA
SSY <- sum((ozone - mean(ozone))^2); SSY
SSE
summary(lm(ozone~garden))
summary.lm(aov(ozone~garden))
oneway
garden
garden[1]
garden[2]
summary(lm(ozone~garden))
mean(ozone[garden=="A"])
mean(ozone[garden=="A"])
mean(ozone[garden=="B"])
sqrt(var(ozone)/length(ozone))
sqrt(var(ozone)/(length(ozone)-1)
sqrt(var(ozone)/(length(ozone)-1))
v = var(ozone)
df = length(ozone) - 1
sqrt(v/df)
summary(lm(ozone~garden))
sqrt(v/df)
sqrt(v/(df+1))
sqrt(var(ozone)/(length(ozone)-1))
sqrt(var(ozone)/(length(ozone)))
length(ozone[garden=="A"])
length(ozone[garden=="B"])
sqrt(var(ozone[garden=="A"])/10 + (var(ozone[garden=="B"])/10)
sqrt(var(ozone[garden=="A"])/10 + (var(ozone[garden=="B"])/10))
sqrt(var(ozone[garden=="A"])/10 + var(ozone[garden=="B"])/10)
summary(lm(ozone~garden))
sqrt(var(ozone[garden=="A"])/10 + var(ozone[garden=="B"])/10)
sqrt(var(ozone)/10)
sqrt(var(ozone)/20)
sqrt(var(ozone[garden=="A"])/10)
mean(ozone[garden=="A"])
sqrt(var(ozone[garden=="A"])/10)
mean(ozone[garden=="B"])
sqrt(var(ozone[garden=="B"])/10)
mean(ozone)
sqrt(var(ozone)/(length(ozone)))
sqrt(var(ozone[garden=="A"])/10 + var(ozone[garden=="B"])/10)
mean(ozone[garden=="B"]) - mean(ozone)
contrasts(ozone)
contrasts(ozone$A)
contrasts(ozone[garden=="A"])
mean(ozone)
a = mean(ozone); a
summary(lm(ozone~garden))
sqrt(var(ozone[garden=="B"])/10 + var(ozone)/10)
sqrt(var(ozone[garden=="A"])/10 + var(ozone[garden=="B"])/10)
sqrt(var(ozone[garden=="A"])/10)
intercept <- mean(ozone[garden=="A"])
slope <- mean(ozone[garden=="B"]) - mean(ozone[garden=="A"])
intercept <- mean(ozone[garden=="A"]); intercept
slope <- mean(ozone[garden=="B"]) - mean(ozone[garden=="A"]); slope
SEintercept <- sqrt(var(ozone[garden=="A"])/10); SEintercept
SEslope <- sqrt(var(ozone[garden=="B"])/10 + var(ozone[garden=="A"])/10); SEslope
summary(lm(ozone~garden))
summary.lm(aov(ozone~garden)) # these two lines are same things
summary(lm(ozone~garden))
tapply(ozone, garden, mean)
tapply(garden, ozone, mean)
detach(oneway)
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/RStats/learnstats/crawleybookcode")
comp <- read.csv("/data/competition.csv")
comp <- read.csv("data/competition.csv")
comp
attach(comp)
plot(clipping, biomass, xlab="Competition treatment", ylab="Biomass", col="dodgerblue")
heights <- tapply(biomass, clipping, mean)
barplot(heights, col="green", ylim=c(0,700), ylab="mean biomass", xlab="competition treatment")
error.bars <- function(listOfBarLengths, error) {
x <- barplot(listOfBarLengths, plot=FALSE)
n <- length(listOfBarLengths)
for(i in 1:n)
arrows(x[i], y[i]-z, x[i], y[i]+z, code=3, angle=90, length=0.15)
}
error.bars <- function(listOfBarLengths, error) {
x <- barplot(listOfBarLengths, plot=FALSE) # finds x-coordinate of bar centers
numErrorBars <- length(listOfBarLengths)
for(i in 1:numErrorBars)
arrows(x[i], y[i]-z, x[i], y[i]+z, code=3, angle=90)
}
se <- rep(28.75, 5)
error.bars(heights, se)
error.bars <- function(y, error) {
x <- barplot(y, plot=FALSE) # finds x-coordinate of bar centers
numErrorBars <- length(y)
for(i in 1:numErrorBars)
arrows(x[i], y[i]-z, x[i], y[i]+z, code=3, angle=90)
}
se <- rep(28.75, 5)
error.bars(heights, se)
error.bars <- function(y, error) {
x <- barplot(y, plot=FALSE) # finds x-coordinate of bar centers
numErrorBars <- length(y)
for(i in 1:numErrorBars)
arrows(x[i], y[i]-error, x[i], y[i]+error, code=3, angle=90)
}
# code=3 means draw heads at both ends of the arrow
# y = the list of bar lengths
se <- rep(28.75, 5)
error.bars(heights, se)
arrows(x[i], y[i]-error, x[i], y[i]+error, code=3, angle=90, length=0.2)
error.bars <- function(y, error) {
x <- barplot(y, plot=FALSE) # finds x-coordinate of bar centers
numErrorBars <- length(y)
for(i in 1:numErrorBars)
arrows(x[i], y[i]-error, x[i], y[i]+error, code=3, angle=90, length=0.2)
}
# code=3 means draw heads at both ends of the arrow
# y = the list of bar lengths
se <- rep(28.75, 5)
error.bars(heights, se)
error.bars <- function(y, error) {
x <- barplot(y, plot=FALSE) # finds x-coordinate of bar centers
numErrorBars <- length(y)
for(i in 1:numErrorBars)
arrows(x[i], y[i]-error, x[i], y[i]+error, code=3, angle=90, length=0.15)
}
# code=3 means draw heads at both ends of the arrow
# y = the list of bar lengths
se <- rep(28.75, 5)
error.bars(heights, se)
barplot(heights, col="green", ylim=c(0,700), ylab="mean biomass", xlab="competition treatment")
model <- aov(biomass~clipping)
summary(model)
model
table(clipping)
SEmean <- sqrt(4961/6)
SEmean <- sqrt(4961/6); SEmean
se <- rep(SEmean, 5)
confint <- SEmean*qt(0.975, df=5)
conflen <- SEmean*qt(0.975, df=5)
ci <- SEmean*qt(0.975, df=5)
barplot(heights, col="blue", ylim=c(0,700),
ylab="mean biomass", xlab="competition treatment")
error.bars(heights, ci)
barplot(heights, col="green", ylim=c(0,700),
ylab="mean biomass", xlab="competition treatment")
error.bars(heights, ci)
summary(model)
least.sig.diff <- qt(0.975, df=10) * sqrt(2*4961/6); least.sig.diff
lsd <- qt(0.975, df=10) * sqrt(2*4961/6); lsd # the two means are significantly different if they differ by 90.61 or more
lsd.bars <- rep(lsd, 5)/2
lsd.bars <- rep(lsd, 5)/2; lsd.bars
barplot(heights, col="green", ylim=c(0,700),
ylab="mean biomass", xlab="competition treatment")
error.bars(heights, ci)
plot(clipping, biomass, xlab="Competition treatment", ylab="Biomass", col="dodgerblue", notch=TRUE)
weights <- read.csv("data/growth.csv")
weights
attach(weights)
detach(comp)
barplot(tapply(gain, list(diet, supplement), mean))
barplot(tapply(gain, list(diet, supplement), mean), beside=TRUE)
barplot(tapply(gain, list(supplement, diet), mean), beside=TRUE)
barplot(tapply(gain, list(diet, supplement), mean), beside=TRUE)
labels <- levels(diet)
labels <- levels(diet); labels
shade <- c(0.2, 0.6, 0.9)
barplot(tapply(gain, list(diet, supplement), mean), beside=TRUE,
ylab="Weight gain", xlab="Supplement", ylim=c(0,30))
legend(locator(1), labels, gray(shade))
q()
