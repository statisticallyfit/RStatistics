# d) TODO why not the same as above?
var.another.W <- pmf.W(1)*(1-mu.W)^2 + pmf.W(2)*(2-mu.W)^2 + pmf.W(3)*(3-mu.W)^2
var.another.W
# NUMBER 2 Integration
f.X <- function(x) { 2*(1 - x) }
# a)
integrate(f.X, 0, 1) # so is valid prob func
# b)
f.ex <- function(x) {2*x*(1-x)}
EX <- integrate(f.ex, 0, 1)
EX
names(EX)
EX$value
# c)
f.var <- function(x) { (x - EX$value)^2 * 2 * (1 - x)}
VAR.X <- integrate(f.var, 0, 1)
VAR.X$value
# NUMBER 3 Dice
# a)
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
# c)
barplot(table(diceSample))
hist(diceSample)
library(ggplot2)
df <- data.frame(diceSample)
ggplot(df, aes(diceSample)) + geom_histogram(binwidth=1, fill='dodgerblue')
rbind(w, pmf.W(w))
pmf.W(w)
sum(pmf.W(w))
mu.W <- pmf.W(1) * 1 + pmf.W(2) * 2 + pmf.W(3) * 3
mu.W
w*pmf.W(w)
sum(w*pmf.W(w))
sum(w^2 * pmf.W(w)) - mu.W^2
var.w <- mu2.W - mu.W^2
var.w
var.W <- sum(w^2 * pmf.W(w)) - mu.W^2
var.W
var.W <- sum(w^2 * pmf.W(w)) - mu.W^2
var.W
var.another.W <- pmf.W(1)*(1-mu.W)^2 + pmf.W(2)*(2-mu.W)^2 + pmf.W(3)*(3-mu.W)^2
var.another.W
f.X <- function(x) { 2*(1 - x) }
# a)
integrate(f.X, 0, 1) # so is valid prob func
f.ex <- function(x) {2*x*(1-x)}
EX <- integrate(f.ex, 0, 1)
EX
names(EX)
EX$value
# c)
f.var <- function(x) { (x - EX$value)^2 * 2 * (1 - x)}
VAR.X <- integrate(f.var, 0, 1)
VAR.X$value
diceSample <- sample(1:6, size=120, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
table(diceSample)/120
# b)
mean(diceSample) # true = 3.5
sqrt(var(diceSample)) # true = 1.708
sd(diceSample)
barplot(table(diceSample))
dice1 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice2 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice3 <- sample(1:6, size=10^4, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice1
diceSum <- dice1 + dice2 + dice3
diceSum
N <- 10^4
probLessTen <- sum(diceSum < 10) / N; probLessTen
head(dice1, dice2, dice3)
head(cbind(dice1, dice2, dice3))
df <- cbind(dice1, dice2, dice3)
df[6,]
unique(df[6,])
df[6,1] == df[6,2] == df[6,3]
df[6,1] == df[6,2] || df[6,1] == df[6,3] || df[6,2] == df[6,3]
rolls <- cbind(dice1, dice2, dice3)
c = -
c = 0
c = 0
c += 1
probFaceValuesAllDifferent
probFaceValuesAllDifferent <- count / N;
probFaceValuesAllDifferent
probFaceValuesAllDifferent <- count / N;
rolls <- cbind(dice1, dice2, dice3)
#unique(df[6,])
count <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count = count + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent <- count / N;
probFaceValuesAllDifferent
count <- 0
unique(rolls)
head(unique(rolls))
head(rolls)
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
count /
count / N
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
count / N
count <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count = count + 1
}
}
count
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(unique(rolls[i, ]) == 3){
# then we increment the count
count = count + 1
}
}
warnings()
count <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count = count + 1
}
}
count
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferen.1
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
assertthat::count.1 == count.2
assertthat(count.1 == count.2)
assert_that(count.1 == count.2)
count.1 == count.2
probFaceValuesAllDifferent.2
1 - pbinom(100, size=105, n = 0.10)
1 - pbinom(100, size=105, prob = 0.10)
pbinom(100, size = 105, prob = 0.10, lower.tail=FALSE)
1 - pbinom(100, size=105, prob = 0.90)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
ppois(11, lambda=10, lower.tail = FALSE)
1 - ppois(11, lambda=10)
p = ppois(11, lambda=10, lower.tail = FALSE)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
1 - pbinom(2, size=8, prob=p)
p = pgeom(2, prob=0.8, lower.tail = FALSE)
p = pgeom(2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
1 - pgeom(2, prob=0.8)
p = pgeom(q=3, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
?pgeom
p = pgeom(q=2, prob=0.8, lower.tail = FALSE); p
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
N <- 10^4
dice1 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice2 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
dice3 <- sample(1:6, size=N, replace=TRUE, prob=c(1/6, 1/6, 1/6, 1/6, 1/6, 1/6))
diceSum <- dice1 + dice2 + dice3
# part a) Probability that sum of face values < 10
probLessTen <- sum(diceSum < 10) / N; probLessTen
rolls <- cbind(dice1, dice2, dice3)
count.1 <- 0
for (i in 1:N){
# if all of the rolls of the 3 dice are not the same for this iteration i,
if(rolls[i, 1] != rolls[i,2] && rolls[i,1] != rolls[i, 3] &&
rolls[i,2] != rolls[i,3]){
# then we do increment the count
count.1 = count.1 + 1
}
}
# the probability we are finding is:
probFaceValuesAllDifferent.1 <- count.1 / N;
probFaceValuesAllDifferent.1
count.2 <- 0
for (i in 1:N){
# if all of the rolls for this row i are unique,
if(length(unique(rolls[i, ])) == 3){
# then we increment the count
count.2 = count.2 + 1
}
}
probFaceValuesAllDifferent.2 <- count.2 / N
probFaceValuesAllDifferent.2
# Test to make sure: Should be true, the two methods yield the same answer.
count.1 == count.2
1 - pbinom(100, size=105, prob = 0.90)
# method 2 of calculating
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Assignment2_questions_1_4_5.R', echo=TRUE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
1 - ppois(11, lambda=10)
pbinom(100, size = 105, prob = 0.90, lower.tail=FALSE)
p = ppois(11, lambda=10, lower.tail = FALSE); p
# method 2
1 - ppois(11, lambda=10)
pbinom(2, size=8, prob=p, lower.tail = FALSE)
# method 2
1 - pbinom(2, size=8, prob=p)
p = pgeom(q=1, prob=0.8, lower.tail = FALSE); p
# Method 2
1 - pgeom(1, prob=0.8)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
# Method 2
1 - pbinom(3, size=10, prob=p)
p = pgeom(q=0, prob=0.8, lower.tail = FALSE); p
1 - pgeom(1, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(2, prob=0.8) # P(X >= 2) = P(X <= 1)
1 - pgeom(0, prob=0.8) # P(X >= 2) = P(X <= 1)
pbinom(3, size=10, prob = p, lower.tail=FALSE)
1 - pbinom(3, size=10, prob=p)
sampleSize <- 10^6
die1 <- sample(x=1:6, size=sampleSize, replace=TRUE) # each prob = 1/6
die2 <- sample(x=1:6, size=sampleSize, replace=TRUE) # each prob = 1/6
jointProb <- table(die1, die2)/sampleSize
jointProb
1/6^2
sampleSize <- 10^7
die1 <- sample(x=1:6, size=sampleSize, replace=TRUE) # each prob = 1/6
die2 <- sample(x=1:6, size=sampleSize, replace=TRUE) # each prob = 1/6
jointProb <- table(die1, die2)/sampleSize
jointProb
1/6^2
jointProb[5:6]
jointProb[5:6,2]
jointProb[5:6] # rows 5,6 and column 1 by default
jointProb[5:6,2] # rows 5,6 and column 2
fives <- (die1 == 5) + (die2==5)
sixes <- (die1 == 6) + (die2 == 6)
jointProb56 <- table(fives, sixes)/sampleSize
jointProb56
2*(1/6)*(2/3) # x = 1, y =0
(1/6)^2 # x = 2, y = 0
2*(1/6)*(2/3) # x= 0, y = 1
2*(1/6)*(1/6) # x= 1, y = 1
(1/6)^2 # x = 0, y = 2
n = 10^5
X = runif(n=n, min=-1, max=1)
Y = runif(n=n, min=-1, max=1)
X
head(X)
probCircle1 <- sum(X^2 + Y^2 <= 1)
probCircle1
probCircle1 <- sum(X^2 + Y^2 <= 1)/n
probCircle1
pi/4
n = 10^5
X = runif(n=n, min=-1, max=1)
Y = runif(n=n, min=-1, max=1)
head(X)
# P(X^2 + Y^2 <= 1) = pi/4
probCircle1 <- sum(X^2 + Y^2 <= 1)/n
pi/4
probCircle1 * 4
n=10^5
X = runif(n=n, min=0, max=1)
Y = runif(n=n, min=0, max=1)
head(X)
X <= 0.5
(X <= 0.5) + (Y <= 0.5)
(X <= 0.5) & (Y <= 0.5)
sum((X <= 0.5) & (Y <= 0.5))/n
probBothBetweenHalf <- sum((X <= 0.5) & (Y <= 0.5))/n
probBothBetweenHalf
dmultinom(x=c(2, 1, 2), size=n, prob=c(0.3, 0.15, 1-0.3-0.15))
n = 5 # sample of 5 crocodiles, prob males = 2, females = 1
dmultinom(x=c(2, 1, 2), size=n, prob=c(0.3, 0.15, 1-0.3-0.15))
nSim <- 10^5
crocs <- sample(c("M", "F", "O"), size=n, prob=c(0.3, 0.15, 0.55), replace=TRUE)
crocs
array(0,3)
crocs[crocs=="M"]
sum(crocs == "M")
names = c("M", "F", "O")
nSim <- 10^5
names = c("M", "F", "O")
counts <- array(0, 3) # holds observed counts of M, F, O
for(i in 1:nSim){
crocs <- sample(c("M", "F", "O"), size=n, prob=c(0.3, 0.15, 0.55), replace=TRUE)
for(j in 1:3){
counts[j] = sum(crocs == names[j])
}
}
counts
X2_Y1 <- 0
diffRandVar <- array(0, nSim)
X2_Y1 <- 0
diffRandVar <- array(0, nSim)
names = c("M", "F", "O")
counts <- array(0, 3) # holds observed counts of M, F, O
for(i in 1:nSim){
crocs <- sample(c("M", "F", "O"), size=n, prob=c(0.3, 0.15, 0.55), replace=TRUE)
for(j in 1:3){
counts[j] = sum(crocs == names[j])
}
# if males = 2, and females = 1
if(counts[1] == 2 && counts[2] == 1){
X2_Y1 <- X2_Y1 + 1
}
diffRandVar[i] <- counts[1] - counts[2]
}
counts
diffRandVar
X2_Y1
prob_X2_Y1 = X2_Y1 / nSim
prob_X2_Y1
mean(diffRandVar)
var(diffRandVar)
nSim <- 10^4
X2_Y1 <- 0
diffRandVar <- array(0, nSim)
names = c("M", "F", "O")
counts <- array(0, 3) # holds observed counts of M, F, O
for(i in 1:nSim){ # we need several tries in order to have counts add up.
crocs <- sample(c("M", "F", "O"), size=n, prob=c(0.3, 0.15, 0.55), replace=TRUE)
for(j in 1:3){
counts[j] = sum(crocs == names[j])
}
# if males = 2, and females = 1
if(counts[1] == 2 && counts[2] == 1){
X2_Y1 <- X2_Y1 + 1
}
diffRandVar[i] <- counts[1] - counts[2]
}
counts
diffRandVar
head(diffRandVar)
X2_Y1
prob_X2_Y1 = X2_Y1 / nSim
prob_X2_Y1 # theoretical ans: 0.1225125
mean(diffRandVar) # theoretical ans: 0.75
var(diffRandVar) # theoretical ans: 2.1375
mu_Ithaca = 29.87
mu_I = 29.87
mu_C = 31.77
sd_I=7.71
sd_C = 7.86
p = 0.957
dnorm(x=-4:4, mean=mu_C, sd=sd_C)
seq(from=-4, to=4, size=10^3)
source('~/.active-rstudio-document', echo=TRUE)
seq(from=-4, to=4, 3)
?seq
xs <- seq(-4, 4, length.out=10)
xs
xs <- seq(-4, 4, length.out=10^3)
ys = dnorm(x=xs, mean=mu_C, sd=sd_C)
plot(xs, ys)
lower <- mu_C - 4 * sd_C
upper <- mu_C + 4 * sd_C
xs <- seq(lower, upper, length.out=10^3)
ys = dnorm(x=xs, mean=mu_C, sd=sd_C)
plot(xs, ys)
library(ggplot2)
df <- data.frame(xs=xs, ys=ys)
ggplot(data=df, aes(x=xs, y=ys)) + geom_density()
df <- data.frame(xs=xs, ys=ys)
ggplot(data=df, aes(x=xs, y=ys)) + geom_density()
head(diamonds)
xs <- seq(lower, upper, length=10^3)
length(xs)
ggplot() + geom_line(data=df, aes(x=xs, y=ys))
ggplot() +
geom_line(data=df, aes(x=xs, y=ys), size=1, colour="blue")
ggplot() +
geom_line(data=df, aes(x=xs, y=ys), size=1, colour="blue") +
geom_vline(xintercept=mu_C, colour="black", linetype="dashed", size=1)
ggplot() +
geom_line(data=df, aes(x=xs, y=ys), size=1, colour="blue") +
geom_vline(xintercept=mu_C, colour="black", linetype="dashed", size=1) +
ggtitle("Normal Density of Canandaigua Max Temperature")
p
5/4 * 2
5/4*2
mu_C_given_I <- function(i) mu_C + p * (sd_C/sd_I) * (i - mu_I)
mu_C_given_I <- function(i) mu_C + p * (sd_C/sd_I) * (i - mu_I)
sd_C_given_I <- sd_C^2 * (1 - p^2)
df.cond <- data.frame(xs=xs, ys=dnorm(x=xs, mean=mu_C_given_I(25), sd=sd_C_given_I))
ggplot() +
geom_line(data=df.cond, aes(x=xs, y=ys), size=1, colour="red") +
geom_vline(xintercept=mu_C_given_I(25), colour="black", linetype="dashed",
size=1) +
ggtitle("Conditional Normal PDF of Canadaigua given Ithaca = 25 degrees F")
df <- data.frame(xs=0:8, ys=dpois(0:8, lambda=0.5))
ggplot(df, aes(x=xs, y=ys)) + geom_point()
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=3, colour="orchid")
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=5, colour="orchid")
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=5, colour="orchid") + geom_linerange(ylim=ys)
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=5, colour="orchid") + geom_linerange(ymin=0,ymax=ys)
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=5, colour="orchid") + geom_linerange(ymin=0,ymax=df$ys)
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=5, colour="orchid") + geom_linerange(ymin=0,ymax=df$ys, size=3, colour="orchid")
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=7, colour="orchid") + geom_linerange(ymin=0,ymax=df$ys, size=2, colour="orchid")
df <- data.frame(xs=0:8, ys=dpois(0:8, lambda=0.9))
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=7, colour="orchid") + geom_linerange(ymin=0,ymax=df$ys, size=2, colour="orchid")
df <- data.frame(xs=0:8, ys=dpois(0:8, lambda=2.9))
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=7, colour="orchid") + geom_linerange(ymin=0,ymax=df$ys, size=2, colour="orchid")
ggplot(df, aes(x=xs, y=ys)) + geom_point(size=7, colour="orchid") + geom_linerange(ymin=0,ymax=df$ys, size=3, colour="orchid")
plotDiscreteDist <- function(xs, ys, colour="black", size.dot=7, size.line=2){
df <- data.frame(xs=xs, ys=ys)
ggplot(df, aes(x=xs, y=ys)) +
geom_point(size=size.dot, colour=colour) +
geom_linerange(ymin=0,ymax=df$ys, size=size.line, colour=colour)
}
plotDiscreteDist(df$xs, df$ys)
plotContinuousDist <- function(xs, ys){
df <- data.frame(xs=xs, ys=ys)
ggplot() +
geom_line(data=df, aes(x=xs, y=ys), size=1, colour="blue") +
geom_vline(xintercept=mean(df$ys),
colour="black", linetype="dashed", size=1)
}
plotContinuousDist(seq(-4, 4, length=1000), dnorm(x=seq(-4,4,length=100)))
xs=seq(-4, 4, length=1000)
plotContinuousDist(xs, dnorm(x=xs))
mean(dnorm(xs))
mean(dnorm(xs,mean=0))
xs=seq(-4, 4, length=1000)
plotContinuousDist(xs, dnorm(x=xs))
ds <- dnorm(xs)
data.frame(ds)
mean(ds)
sd(ds)
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/Module 4_5 - Discrete and Continuous Distributions")
setwd("/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/")
source("/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/PLOTTING_PROB.R")
xs = seq(0:8)
ys = dpois(x=xs, lambda=1/2)
plotDiscreteDist(xs, ys)
xs\
xs #
xs = 0:8
ys = dpois(x=xs, lambda=1/2)
plotDiscreteDist(xs, ys)
source('/datascience/projects/statisticallyfit/github/R/RStatistics/MATH260 Probability and Simulation/PLOTTING_PROB.R', echo=TRUE)
plotDiscreteDist(xs, ys)
pbinom(6, size=15, prob=0.2, lower.tail = F)
pbinom(4, size=15, prob=0.2, lower.tail = F)
dgeom(x=4, prob=0.2)
pexp(3, rate=2, lower.tail = F)
1-pexp(2, rate=2)
pexp(2, rate=2, lower.tail = F)
1 - pexp(2, rate=2)
1 - pexp(3, rate=2)
1 - pexp(1, rate=2)
1 - pexp(0, rate=2)
1-ppois(q=2, lambda=2)
ppois(2, lambda=2, lower.tail=F)
p=1-ppois(q=2, lambda=2)
pbinom(2, size=5, prob=p,lower.tail = F)
1-pbinom(0, size=5, prob=p)
1-dbinom(0, size=5, prob=p)
pbinom(0, size=5, prob=p,lower.tail = F)
pbinom(3, size=5, prob=0.85,lower.tail = FALSE)
1-pbinom(3, size=5, prob=0.85)
qnorm(0.005)
*-4
-2.575829*-4
pnorm(9, mean=12,sd=4)
pnorm(17, 12,4,lower.tail=F)
diff(pnorm(c(0,18),12,4))
pexp(60, rate=40, lower.tail = F)
1-pexp(60,rate=40)
