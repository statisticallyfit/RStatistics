license
version
qf(0.025, df1=3, df2=11, lower.tail=F)
qf(0.05, df1=2, df2=11, lower.tail=FALS )
qf(0.05, df1=2, df2=11, lower.tail=FALSE
)
qf(0.05, df1=1, df2=3, lower.tail=F)
x.lc50.static <- c(39, 37.5, 22.2, 17.5, 0.64, 0.45, 2.62, 2.36, 32, 0.77)
x.lc50.static <- c(39, 37.5, 22.2, 17.5, 0.64, 0.45, 2.62, 2.36, 32, 0.77)
y.lc50.flow <- c(23, 22.3, 9.4, 9.7, 0.15, 0.28, 0.75, 0.51, 28, 0.39)
simple.lm <- lm(y.lc50.flow ~ x.lc50.static)
summary(simple.lm)
options(show.signif.stars = F)
summary(simple.lm)
data <- (X = x.lc50.static, Y=y.lc50.flow)
data <- data.frame(X = x.lc50.static, Y=y.lc50.flow)
ggplot(data, aes(x=x.lc50.static, y=y.lc50.flow)) + geom_point(shape=19)
library(ggplot2)
ggplot(data, aes(x=x.lc50.static, y=y.lc50.flow)) + geom_point(shape=19)
logx.lm <- lm(y.lc50.flow ~ log(x.lc50.static), data=data)
summary(logx.lm)
setwd("/development/projects/statisticallyfit/github/R/RStatistics/STAT270 Inference/Week 6 - Linear Models")
data <- read.table("ISEdata.txt")
data#
data <- read.table("ISEdata.txt", header=TRUE)
data #
summary(lm(log10x ~ emf, data=data))
LC_ISE_nitric = c(120, 77, 435, 3973, 309, 38, 30, 291)
AAS_nitric = c(190, 140, 1270, 11800, 710, 60, 40, 360)
y = log10(LC_ISE_nitric)
log10_LC = log10(LC_ISE_nitric)
log10_AAS = log10(AAS_nitric)
data = data.frame(x=log10_AAS, y= log10_LC)
lead.lm <- lm(y ~ x, data=data)
summary(lead.lm)
leadlog.lm <- lm(y ~ x, data=data)
summary(leadlog.lm)
data = data.frame(log10_AAS=log10_AAS, log10_LC= log10_LC)
leadlog.lm <- lm(log10_LC ~ log10_AAS, data=data)
summary(leadlog.lm)
leadlog.nointercept.lm <- lm(log10_LC ~ log10_AAS - 1, data=data)
summary(leadlog.nointercept.lm)
b1.hat <- summary(leadlog.lm)$coef
b1.hat
b1.hat[2,1]
b1.hat <- summary(leadlog.lm)$coef[2]
b1.hat
se = summary(leadlog.lm)[1,2]
se = (summary(leadlog.lm))[1,2]
summary(leadlog.lm)$coef
se = (summary(leadlog.lm))$coef[1,2]
se
t = (b1.hat - 1)/se; t
b1.hat/se
se = (summary(leadlog.lm))$coef[2,2]
t = (b1.hat - 1)/se; t
b1.hat/se
summary(leadlog.lm)
b1.hat/se
t = (b1.hat - 1)/se; t
b1.hat <- summary(leadlog.lm)$coef[2]; b1.hat
n = nrow(data)
n = nrow(data); n
p.value = 2*pt(t, df=n-2, lower.tail=TRUE); p.value
qt(0.025, df=8-2)
crit = qt(0.025, df=n-2) * -1; crit
se
lower = b1.hat - crit * se
upper = b1.hat + crit * se; upper
anova(leadlog.lm)
x = cbind(rep(1,5), c(12, 3,4,5,6))
y= c(20, 6, 9, 11, 14)
x = cbind(rep(1,5), c(12, 3,4,5,6)); x
y= c(20, 6, 9, 11, 14); y
invX = inv(t(x) %*% x)
solve(matric(c(7, 0, 0, 4), nrow=2))
solve(matrix(c(7, 0, 0, 4), nrow=2))
1/7 #
beta.hat = solve(t(x) %*% x) %*% (t(x) %*% y)
beta.hat
y.fit = X %*% beta.hat; y.fit
y.fit = x %*% beta.hat; y.fit
lm(y ~ x[,2])$fit
e = y - y.fit; e
lm(y ~ x[,2])$resid
sse = t(y) %*% y - t(beta.hat) %*% (t(x) %*% y); sse
model = lm(y ~ x[,2])
model$fit
model$residuals
n = nrow(x); n
k = ncol(x) - 1; k
s = sqrt(sse / (n-k-1)); s
summary(model)
summary(model)$stand
varcov.mat = s^2 * inv(t(x) %*% x)
varcov.mat = s^2 * solve(t(x) %*% x)
x
varcov.mat = solve(t(x) %*% x)
varcov.mat = solve(t(x) %*% x) * s^2; varcov.mat
s^2
varcov.mat = s^2 * (solve(t(x) %*% x)) varcov.mat
varcov.mat = s^2 * (solve(t(x) %*% x)); varcov.mat
temp = solve(t(x) %*% x)
s^2 * temp
dim(temp)
rep(dim(temp))
dim(temp)
matrix(rep(dim(temp)), s^2)
const = matrix(rep(2,2), s^2)
const
temp
temp = solve(t(x) %*% x)
temp[1,1]*s^2
varhat = s^2
varhat * temp
varhat * solve(t(x) %*% x)
varhat.as.matrix = matrix(rep(2*2), s^2, nrow=2); varhat.as.matrix
?rep
varhat.as.matrix = matrix(rep(s^2, 2*2), nrow=2); varhat.as.matrix
varcov.mat = varhat.as.matrix * solve(t(x) %*% x); varcov.mat
a.vector.x.star = c(1,3)
a.vector.x.star %*% beta.hat
y.hat.pred = a.vector.x.star %*% beta.hat; y.hat.pred
varhat.as.matrix * (t(a.vector.x.star) %*% solve(t(x) %*% x) %*% a.vector.x.star)
(t(a.vector.x.star) %*% solve(t(x) %*% x) %*% a.vector.x.star)
sderr.mean.ci = s^2 * (t(a.vector.x.star) %*% solve(t(x) %*% x) %*% a.vector.x.star)
stderr.mean.ci
sderr.mean.ci = s^2 * (t(a.vector.x.star) %*% solve(t(x) %*% x) %*% a.vector.x.star)
stderr.mean.ci
stderr.mean.ci = s^2 * (t(a.vector.x.star) %*% solve(t(x) %*% x) %*% a.vector.x.star)
stderr.mean.ci
stderr.mean.ci = sqrt(s^2 * (t(a.vector.x.star) %*% solve(t(x) %*% x) %*% a.vector.x.star))
stderr.mean.ci
x
lm1 = lm(y ~ x[,2])
summary(lm1)
predict(lm1, newdata=list(x=3), se.fit=TRUE)
predict(lm1, newdata=list(x=3), se.fit=TRUE)$fit
x[,2]
y
names(lm1)
lm1$model
predict(lm1, newdata=list(x[,2]=3), se.fit=TRUE)$fit
lm1 = lm(y ~ tempx)
tempx = x[,2]
lm1 = lm(y ~ tempx)
predict(lm1, newdata=list(tempx=3), se.fit=TRUE)$fit
predict(lm1, newdata=list(tempx=3), se.fit=TRUE)
sse
Syy = t(y - mean(y))
Syy
Syy = t(y - mean(y)) %*% (y - mean(y)); Syy
sse
R2 = 1 - sse/Syy; R2
summary(lm1)
R2
fit = predict(lm1, newdata=list(tempx=3), se.fit=TRUE)$fit
stderr.PI = sqrt(s^2 * (1 + t(a.vector.x.star) %*% solve(t(x) %*% x) %*% a.vector.x.star))
lower = fit - stderr.PI
upper = fit + stderr.PI
lower = fit - stderr.PI; lower
upper = fit + stderr.PI; upper
stderr.PI
predict(lm1, newdata=list(tempx=3), se.fit=TRUE, interval="pred")
crit = qt(0.025, df=n-2) * -1
crit = qt(0.025, df=n-2) * -1; crit
upper = fit + crit*stderr.PI; upper
lower = fit - crit*stderr.PI; lower
predict(lm1, newdata=list(tempx=3), se.fit=TRUE, interval="pred")
yieldData <- read.table("example1174data.xlsx", header=TRUE)
yieldData <- read.csv("example1174data.xlsx", header=TRUE)
yieldData <- read.xls("example1174data.xlsx", header=TRUE)
library(gdata)
yieldData <- read.xls("example1174data.xlsx", header=TRUE)
yieldData
yield.lm <- lm(y ~ x1 + x2 + x3 + x4, data=yield)
summary(yield.lm)
yield.lm <- lm(y ~ x1 + x2 + x3 + x4, data=yieldData)
summary(yield.lm)
X = cbind(rep(1,16), yieldData$x1, yieldData$x2, yieldData$x3, yieldData$x4)
X
Y = yieldData$y
betahat = solve(t(X) %*% X) %*% (t(X) %*% Y); betahat
yield.lm$coef
summary(yield.lm)
XR = cbind(rep(1,16), yieldData$x1)
X.reduced = cbind(rep(1,16), yieldData$x1)
betahat.reduced = solve(t(X.reduced) %*% X.reduced) %*% (t(X.reduced) %*% Y); betahat
betahat.reduced = solve(t(X.reduced) %*% X.reduced) %*% (t(X.reduced) %*% Y); betahat.reduced
SSE.C = t(Y) %*% Y - t(betahat) %*% (t(X) %*% Y); SSE.C
anova(yield.lm)
SSE.R = t(Y) %*% Y - t(betahat.reduced) %*% (t(X.reduced) %*% Y); SSE.R
anova(lm(y ~ x1, data=yieldData))
k = 4
g = 1
n = nrow(yieldData)
Fstat = ((SSE.R - SSE.C) / (k-g)) / (SSE.C / (n-k-1)); Fstat
yield.reduced.lm = lm(y ~ x1, data=yieldData) # reduced model
anova(yield.reduced.lm, yield.lm)
p.value = pf(Fstat, df1=k-g, df2=n-k-1, lower.tail=F)
p.value
